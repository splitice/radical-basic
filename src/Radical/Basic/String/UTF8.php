<?php
namespace Basic\String;

/**
 * Provides string functions for UTF-8 strings
 *
 * This class is implemented to provide a UTF-8 version of almost every built-in
 * PHP string function. For more information about UTF-8, please visit
 * http://flourishlib.com/docs/UTF-8.
 * 
 * @copyright  Copyright (c) 2008-2011 Will Bond
 * @author     Will Bond [wb] <will@flourishlib.com>
 * @license    http://flourishlib.com/license
 *
 * @package    Flourish
 * @link       http://flourishlib.com/fUTF8
 * 
 * @version    1.0.0b15
 */
class UTF8 extends \Core\Object
{
	// The following constants allow for nice looking callbacks to static methods
	const ascii    = 'fUTF8::ascii';
	const chr      = 'fUTF8::chr';
	const clean    = 'fUTF8::clean';
	const cmp      = 'fUTF8::cmp';
	const explode  = 'fUTF8::explode';
	const icmp     = 'fUTF8::icmp';
	const inatcmp  = 'fUTF8::inatcmp';
	const ipos     = 'fUTF8::ipos';
	const ireplace = 'fUTF8::ireplace';
	const irpos    = 'fUTF8::irpos';
	const istr     = 'fUTF8::istr';
	const len      = 'fUTF8::len';
	const lower    = 'fUTF8::lower';
	const ltrim    = 'fUTF8::ltrim';
	const natcmp   = 'fUTF8::natcmp';
	const ord      = 'fUTF8::ord';
	const pad      = 'fUTF8::pad';
	const pos      = 'fUTF8::pos';
	const replace  = 'fUTF8::replace';
	const reset    = 'fUTF8::reset';
	const rev      = 'fUTF8::rev';
	const rpos     = 'fUTF8::rpos';
	const rtrim    = 'fUTF8::rtrim';
	const str      = 'fUTF8::str';
	const sub      = 'fUTF8::sub';
	const trim     = 'fUTF8::trim';
	const ucfirst  = 'fUTF8::ucfirst';
	const ucwords  = 'fUTF8::ucwords';
	const upper    = 'fUTF8::upper';
	const wordwrap = 'fUTF8::wordwrap';


	/**
	 * Depending how things are compiled, NetBSD and Solaris don't support //IGNORE in iconv()
	 *
	 * If //IGNORE support is not provided strings with invalid characters will be truncated
	 *
	 * @var boolean
	 */
	static private $can_ignore_invalid = NULL;

	/**
	 * All lowercase UTF-8 characters mapped to uppercase characters
	 *
	 * @var array
	 */
	static private $lower_to_upper = array(
		'a' => 'A', 'b' => 'B', 'c' => 'C', 'd' => 'D', 'e' => 'E', 'f' => 'F',
		'g' => 'G', 'h' => 'H', 'i' => 'I', 'j' => 'J', 'k' => 'K', 'l' => 'L',
		'm' => 'M', 'n' => 'N', 'o' => 'O', 'p' => 'P', 'q' => 'Q', 'r' => 'R',
		's' => 'S', 't' => 'T', 'u' => 'U', 'v' => 'V', 'w' => 'W', 'x' => 'X',
		'y' => 'Y', 'z' => 'Z', 'Ã ' => 'Ã€', 'Ã¡' => 'Ã�', 'Ã¢' => 'Ã‚', 'Ã£' => 'Ãƒ',
		'Ã¤' => 'Ã„', 'Ã¥' => 'Ã…', 'Ã¦' => 'Ã†', 'Ã§' => 'Ã‡', 'Ã¨' => 'Ãˆ', 'Ã©' => 'Ã‰',
		'Ãª' => 'ÃŠ', 'Ã«' => 'Ã‹', 'Ã¬' => 'ÃŒ', 'Ã­' => 'Ã�', 'Ã®' => 'ÃŽ', 'Ã¯' => 'Ã�',
		'Ã°' => 'Ã�', 'Ã±' => 'Ã‘', 'Ã²' => 'Ã’', 'Ã³' => 'Ã“', 'Ã´' => 'Ã”', 'Ãµ' => 'Ã•',
		'Ã¶' => 'Ã–', 'Ã¸' => 'Ã˜', 'Ã¹' => 'Ã™', 'Ãº' => 'Ãš', 'Ã»' => 'Ã›', 'Ã¼' => 'Ãœ',
		'Ã½' => 'Ã�', 'Ã¾' => 'Ãž', 'Ä�' => 'Ä€', 'Äƒ' => 'Ä‚', 'Ä…' => 'Ä„', 'Ä‡' => 'Ä†',
		'Ä‰' => 'Äˆ', 'Ä‹' => 'ÄŠ', 'Ä�' => 'ÄŒ', 'Ä�' => 'ÄŽ', 'Ä‘' => 'Ä�', 'Ä“' => 'Ä’',
		'Ä•' => 'Ä”', 'Ä—' => 'Ä–', 'Ä™' => 'Ä˜', 'Ä›' => 'Äš', 'Ä�' => 'Äœ', 'ÄŸ' => 'Äž',
		'Ä¡' => 'Ä ', 'Ä£' => 'Ä¢', 'Ä¥' => 'Ä¤', 'Ä§' => 'Ä¦', 'Ä©' => 'Ä¨', 'Ä«' => 'Äª',
		'Ä­' => 'Ä¬', 'Ä¯' => 'Ä®', 'Ä³' => 'Ä²', 'Äµ' => 'Ä´', 'Ä·' => 'Ä¶', 'Äº' => 'Ä¹',
		'Ä¼' => 'Ä»', 'Ä¾' => 'Ä½', 'Å€' => 'Ä¿', 'Å‚' => 'Å�', 'Å„' => 'Åƒ', 'Å†' => 'Å…',
		'Åˆ' => 'Å‡', 'Å‹' => 'ÅŠ', 'Å�' => 'ÅŒ', 'Å�' => 'ÅŽ', 'Å‘' => 'Å�', 'Å“' => 'Å’',
		'Å•' => 'Å”', 'Å—' => 'Å–', 'Å™' => 'Å˜', 'Å›' => 'Åš', 'Å�' => 'Åœ', 'ÅŸ' => 'Åž',
		'Å¡' => 'Å ', 'Å£' => 'Å¢', 'Å¥' => 'Å¤', 'Å§' => 'Å¦', 'Å©' => 'Å¨', 'Å«' => 'Åª',
		'Å­' => 'Å¬', 'Å¯' => 'Å®', 'Å±' => 'Å°', 'Å³' => 'Å²', 'Åµ' => 'Å´', 'Å·' => 'Å¶',
		'Ã¿' => 'Å¸', 'Åº' => 'Å¹', 'Å¼' => 'Å»', 'Å¾' => 'Å½', 'É“' => 'Æ�', 'Æƒ' => 'Æ‚',
		'Æ…' => 'Æ„', 'É”' => 'Æ†', 'Æˆ' => 'Æ‡', 'É—' => 'ÆŠ', 'ÆŒ' => 'Æ‹', 'É˜' => 'ÆŽ',
		'É™' => 'Æ�', 'É›' => 'Æ�', 'Æ’' => 'Æ‘', 'É ' => 'Æ“', 'É£' => 'Æ”', 'É©' => 'Æ–',
		'É¨' => 'Æ—', 'Æ™' => 'Æ˜', 'É¯' => 'Æœ', 'É²' => 'Æ�', 'Éµ' => 'ÆŸ', 'Æ¡' => 'Æ ',
		'Æ£' => 'Æ¢', 'Æ¥' => 'Æ¤', 'Æ¨' => 'Æ§', 'Êƒ' => 'Æ©', 'Æ­' => 'Æ¬', 'Êˆ' => 'Æ®',
		'Æ°' => 'Æ¯', 'ÊŠ' => 'Æ±', 'Ê‹' => 'Æ²', 'Æ´' => 'Æ³', 'Æ¶' => 'Æµ', 'Ê’' => 'Æ·',
		'Æ¹' => 'Æ¸', 'Æ½' => 'Æ¼', 'Ç†' => 'Ç„', 'Ç†' => 'Ç…', 'Ç‰' => 'Ç‡', 'Ç‰' => 'Çˆ',
		'ÇŒ' => 'ÇŠ', 'ÇŒ' => 'Ç‹', 'ÇŽ' => 'Ç�', 'Ç�' => 'Ç�', 'Ç’' => 'Ç‘', 'Ç”' => 'Ç“',
		'Ç–' => 'Ç•', 'Ç˜' => 'Ç—', 'Çš' => 'Ç™', 'Çœ' => 'Ç›', 'ÇŸ' => 'Çž', 'Ç¡' => 'Ç ',
		'Ç£' => 'Ç¢', 'Ç¥' => 'Ç¤', 'Ç§' => 'Ç¦', 'Ç©' => 'Ç¨', 'Ç«' => 'Çª', 'Ç­' => 'Ç¬',
		'Ç¯' => 'Ç®', 'Ç³' => 'Ç±', 'Çµ' => 'Ç´', 'Ç»' => 'Çº', 'Ç½' => 'Ç¼', 'Ç¿' => 'Ç¾',
		'È�' => 'È€', 'Èƒ' => 'È‚', 'È…' => 'È„', 'È‡' => 'È†', 'È‰' => 'Èˆ', 'È‹' => 'ÈŠ',
		'È�' => 'ÈŒ', 'È�' => 'ÈŽ', 'È‘' => 'È�', 'È“' => 'È’', 'È•' => 'È”', 'È—' => 'È–',
		'Î¬' => 'Î†', 'Î­' => 'Îˆ', 'Î®' => 'Î‰', 'Î¯' => 'ÎŠ', 'ÏŒ' => 'ÎŒ', 'Ï�' => 'ÎŽ',
		'ÏŽ' => 'Î�', 'Î±' => 'Î‘', 'Î²' => 'Î’', 'Î³' => 'Î“', 'Î´' => 'Î”', 'Îµ' => 'Î•',
		'Î¶' => 'Î–', 'Î·' => 'Î—', 'Î¸' => 'Î˜', 'Î¹' => 'Î™', 'Îº' => 'Îš', 'Î»' => 'Î›',
		'Î¼' => 'Îœ', 'Î½' => 'Î�', 'Î¾' => 'Îž', 'Î¿' => 'ÎŸ', 'Ï€' => 'Î ', 'Ï�' => 'Î¡',
		'Ïƒ' => 'Î£', 'Ï„' => 'Î¤', 'Ï…' => 'Î¥', 'Ï†' => 'Î¦', 'Ï‡' => 'Î§', 'Ïˆ' => 'Î¨',
		'Ï‰' => 'Î©', 'ÏŠ' => 'Îª', 'Ï‹' => 'Î«', 'Ï£' => 'Ï¢', 'Ï¥' => 'Ï¤', 'Ï§' => 'Ï¦',
		'Ï©' => 'Ï¨', 'Ï«' => 'Ïª', 'Ï­' => 'Ï¬', 'Ï¯' => 'Ï®', 'Ñ‘' => 'Ð�', 'Ñ’' => 'Ð‚',
		'Ñ“' => 'Ðƒ', 'Ñ”' => 'Ð„', 'Ñ•' => 'Ð…', 'Ñ–' => 'Ð†', 'Ñ—' => 'Ð‡', 'Ñ˜' => 'Ðˆ',
		'Ñ™' => 'Ð‰', 'Ñš' => 'ÐŠ', 'Ñ›' => 'Ð‹', 'Ñœ' => 'ÐŒ', 'Ñž' => 'ÐŽ', 'ÑŸ' => 'Ð�',
		'Ð°' => 'Ð�', 'Ð±' => 'Ð‘', 'Ð²' => 'Ð’', 'Ð³' => 'Ð“', 'Ð´' => 'Ð”', 'Ðµ' => 'Ð•',
		'Ð¶' => 'Ð–', 'Ð·' => 'Ð—', 'Ð¸' => 'Ð˜', 'Ð¹' => 'Ð™', 'Ðº' => 'Ðš', 'Ð»' => 'Ð›',
		'Ð¼' => 'Ðœ', 'Ð½' => 'Ð�', 'Ð¾' => 'Ðž', 'Ð¿' => 'ÐŸ', 'Ñ€' => 'Ð ', 'Ñ�' => 'Ð¡',
		'Ñ‚' => 'Ð¢', 'Ñƒ' => 'Ð£', 'Ñ„' => 'Ð¤', 'Ñ…' => 'Ð¥', 'Ñ†' => 'Ð¦', 'Ñ‡' => 'Ð§',
		'Ñˆ' => 'Ð¨', 'Ñ‰' => 'Ð©', 'ÑŠ' => 'Ðª', 'Ñ‹' => 'Ð«', 'ÑŒ' => 'Ð¬', 'Ñ�' => 'Ð­',
		'ÑŽ' => 'Ð®', 'Ñ�' => 'Ð¯', 'Ñ¡' => 'Ñ ', 'Ñ£' => 'Ñ¢', 'Ñ¥' => 'Ñ¤', 'Ñ§' => 'Ñ¦',
		'Ñ©' => 'Ñ¨', 'Ñ«' => 'Ñª', 'Ñ­' => 'Ñ¬', 'Ñ¯' => 'Ñ®', 'Ñ±' => 'Ñ°', 'Ñ³' => 'Ñ²',
		'Ñµ' => 'Ñ´', 'Ñ·' => 'Ñ¶', 'Ñ¹' => 'Ñ¸', 'Ñ»' => 'Ñº', 'Ñ½' => 'Ñ¼', 'Ñ¿' => 'Ñ¾',
		'Ò�' => 'Ò€', 'Ò‘' => 'Ò�', 'Ò“' => 'Ò’', 'Ò•' => 'Ò”', 'Ò—' => 'Ò–', 'Ò™' => 'Ò˜',
		'Ò›' => 'Òš', 'Ò�' => 'Òœ', 'ÒŸ' => 'Òž', 'Ò¡' => 'Ò ', 'Ò£' => 'Ò¢', 'Ò¥' => 'Ò¤',
		'Ò§' => 'Ò¦', 'Ò©' => 'Ò¨', 'Ò«' => 'Òª', 'Ò­' => 'Ò¬', 'Ò¯' => 'Ò®', 'Ò±' => 'Ò°',
		'Ò³' => 'Ò²', 'Òµ' => 'Ò´', 'Ò·' => 'Ò¶', 'Ò¹' => 'Ò¸', 'Ò»' => 'Òº', 'Ò½' => 'Ò¼',
		'Ò¿' => 'Ò¾', 'Ó‚' => 'Ó�', 'Ó„' => 'Óƒ', 'Óˆ' => 'Ó‡', 'ÓŒ' => 'Ó‹', 'Ó‘' => 'Ó�',
		'Ó“' => 'Ó’', 'Ó•' => 'Ó”', 'Ó—' => 'Ó–', 'Ó™' => 'Ó˜', 'Ó›' => 'Óš', 'Ó�' => 'Óœ',
		'ÓŸ' => 'Óž', 'Ó¡' => 'Ó ', 'Ó£' => 'Ó¢', 'Ó¥' => 'Ó¤', 'Ó§' => 'Ó¦', 'Ó©' => 'Ó¨',
		'Ó«' => 'Óª', 'Ó¯' => 'Ó®', 'Ó±' => 'Ó°', 'Ó³' => 'Ó²', 'Óµ' => 'Ó´', 'Ó¹' => 'Ó¸',
		'Õ¡' => 'Ô±', 'Õ¢' => 'Ô²', 'Õ£' => 'Ô³', 'Õ¤' => 'Ô´', 'Õ¥' => 'Ôµ', 'Õ¦' => 'Ô¶',
		'Õ§' => 'Ô·', 'Õ¨' => 'Ô¸', 'Õ©' => 'Ô¹', 'Õª' => 'Ôº', 'Õ«' => 'Ô»', 'Õ¬' => 'Ô¼',
		'Õ­' => 'Ô½', 'Õ®' => 'Ô¾', 'Õ¯' => 'Ô¿', 'Õ°' => 'Õ€', 'Õ±' => 'Õ�', 'Õ²' => 'Õ‚',
		'Õ³' => 'Õƒ', 'Õ´' => 'Õ„', 'Õµ' => 'Õ…', 'Õ¶' => 'Õ†', 'Õ·' => 'Õ‡', 'Õ¸' => 'Õˆ',
		'Õ¹' => 'Õ‰', 'Õº' => 'ÕŠ', 'Õ»' => 'Õ‹', 'Õ¼' => 'ÕŒ', 'Õ½' => 'Õ�', 'Õ¾' => 'ÕŽ',
		'Õ¿' => 'Õ�', 'Ö€' => 'Õ�', 'Ö�' => 'Õ‘', 'Ö‚' => 'Õ’', 'Öƒ' => 'Õ“', 'Ö„' => 'Õ”',
		'Ö…' => 'Õ•', 'Ö†' => 'Õ–', 'áƒ�' => 'á‚ ', 'áƒ‘' => 'á‚¡', 'áƒ’' => 'á‚¢', 'áƒ“' => 'á‚£',
		'áƒ”' => 'á‚¤', 'áƒ•' => 'á‚¥', 'áƒ–' => 'á‚¦', 'áƒ—' => 'á‚§', 'áƒ˜' => 'á‚¨', 'áƒ™' => 'á‚©',
		'áƒš' => 'á‚ª', 'áƒ›' => 'á‚«', 'áƒœ' => 'á‚¬', 'áƒ�' => 'á‚­', 'áƒž' => 'á‚®', 'áƒŸ' => 'á‚¯',
		'áƒ ' => 'á‚°', 'áƒ¡' => 'á‚±', 'áƒ¢' => 'á‚²', 'áƒ£' => 'á‚³', 'áƒ¤' => 'á‚´', 'áƒ¥' => 'á‚µ',
		'áƒ¦' => 'á‚¶', 'áƒ§' => 'á‚·', 'áƒ¨' => 'á‚¸', 'áƒ©' => 'á‚¹', 'áƒª' => 'á‚º', 'áƒ«' => 'á‚»',
		'áƒ¬' => 'á‚¼', 'áƒ­' => 'á‚½', 'áƒ®' => 'á‚¾', 'áƒ¯' => 'á‚¿', 'áƒ°' => 'áƒ€', 'áƒ±' => 'áƒ�',
		'áƒ²' => 'áƒ‚', 'áƒ³' => 'áƒƒ', 'áƒ´' => 'áƒ„', 'áƒµ' => 'áƒ…', 'á¸�' => 'á¸€', 'á¸ƒ' => 'á¸‚',
		'á¸…' => 'á¸„', 'á¸‡' => 'á¸†', 'á¸‰' => 'á¸ˆ', 'á¸‹' => 'á¸Š', 'á¸�' => 'á¸Œ', 'á¸�' => 'á¸Ž',
		'á¸‘' => 'á¸�', 'á¸“' => 'á¸’', 'á¸•' => 'á¸”', 'á¸—' => 'á¸–', 'á¸™' => 'á¸˜', 'á¸›' => 'á¸š',
		'á¸�' => 'á¸œ', 'á¸Ÿ' => 'á¸ž', 'á¸¡' => 'á¸ ', 'á¸£' => 'á¸¢', 'á¸¥' => 'á¸¤', 'á¸§' => 'á¸¦',
		'á¸©' => 'á¸¨', 'á¸«' => 'á¸ª', 'á¸­' => 'á¸¬', 'á¸¯' => 'á¸®', 'á¸±' => 'á¸°', 'á¸³' => 'á¸²',
		'á¸µ' => 'á¸´', 'á¸·' => 'á¸¶', 'á¸¹' => 'á¸¸', 'á¸»' => 'á¸º', 'á¸½' => 'á¸¼', 'á¸¿' => 'á¸¾',
		'á¹�' => 'á¹€', 'á¹ƒ' => 'á¹‚', 'á¹…' => 'á¹„', 'á¹‡' => 'á¹†', 'á¹‰' => 'á¹ˆ', 'á¹‹' => 'á¹Š',
		'á¹�' => 'á¹Œ', 'á¹�' => 'á¹Ž', 'á¹‘' => 'á¹�', 'á¹“' => 'á¹’', 'á¹•' => 'á¹”', 'á¹—' => 'á¹–',
		'á¹™' => 'á¹˜', 'á¹›' => 'á¹š', 'á¹�' => 'á¹œ', 'á¹Ÿ' => 'á¹ž', 'á¹¡' => 'á¹ ', 'á¹£' => 'á¹¢',
		'á¹¥' => 'á¹¤', 'á¹§' => 'á¹¦', 'á¹©' => 'á¹¨', 'á¹«' => 'á¹ª', 'á¹­' => 'á¹¬', 'á¹¯' => 'á¹®',
		'á¹±' => 'á¹°', 'á¹³' => 'á¹²', 'á¹µ' => 'á¹´', 'á¹·' => 'á¹¶', 'á¹¹' => 'á¹¸', 'á¹»' => 'á¹º',
		'á¹½' => 'á¹¼', 'á¹¿' => 'á¹¾', 'áº�' => 'áº€', 'áºƒ' => 'áº‚', 'áº…' => 'áº„', 'áº‡' => 'áº†',
		'áº‰' => 'áºˆ', 'áº‹' => 'áºŠ', 'áº�' => 'áºŒ', 'áº�' => 'áºŽ', 'áº‘' => 'áº�', 'áº“' => 'áº’',
		'áº•' => 'áº”', 'áº¡' => 'áº ', 'áº£' => 'áº¢', 'áº¥' => 'áº¤', 'áº§' => 'áº¦', 'áº©' => 'áº¨',
		'áº«' => 'áºª', 'áº­' => 'áº¬', 'áº¯' => 'áº®', 'áº±' => 'áº°', 'áº³' => 'áº²', 'áºµ' => 'áº´',
		'áº·' => 'áº¶', 'áº¹' => 'áº¸', 'áº»' => 'áºº', 'áº½' => 'áº¼', 'áº¿' => 'áº¾', 'á»�' => 'á»€',
		'á»ƒ' => 'á»‚', 'á»…' => 'á»„', 'á»‡' => 'á»†', 'á»‰' => 'á»ˆ', 'á»‹' => 'á»Š', 'á»�' => 'á»Œ',
		'á»�' => 'á»Ž', 'á»‘' => 'á»�', 'á»“' => 'á»’', 'á»•' => 'á»”', 'á»—' => 'á»–', 'á»™' => 'á»˜',
		'á»›' => 'á»š', 'á»�' => 'á»œ', 'á»Ÿ' => 'á»ž', 'á»¡' => 'á» ', 'á»£' => 'á»¢', 'á»¥' => 'á»¤',
		'á»§' => 'á»¦', 'á»©' => 'á»¨', 'á»«' => 'á»ª', 'á»­' => 'á»¬', 'á»¯' => 'á»®', 'á»±' => 'á»°',
		'á»³' => 'á»²', 'á»µ' => 'á»´', 'á»·' => 'á»¶', 'á»¹' => 'á»¸', 'á¼€' => 'á¼ˆ', 'á¼�' => 'á¼‰',
		'á¼‚' => 'á¼Š', 'á¼ƒ' => 'á¼‹', 'á¼„' => 'á¼Œ', 'á¼…' => 'á¼�', 'á¼†' => 'á¼Ž', 'á¼‡' => 'á¼�',
		'á¼�' => 'á¼˜', 'á¼‘' => 'á¼™', 'á¼’' => 'á¼š', 'á¼“' => 'á¼›', 'á¼”' => 'á¼œ', 'á¼•' => 'á¼�',
		'á¼ ' => 'á¼¨', 'á¼¡' => 'á¼©', 'á¼¢' => 'á¼ª', 'á¼£' => 'á¼«', 'á¼¤' => 'á¼¬', 'á¼¥' => 'á¼­',
		'á¼¦' => 'á¼®', 'á¼§' => 'á¼¯', 'á¼°' => 'á¼¸', 'á¼±' => 'á¼¹', 'á¼²' => 'á¼º', 'á¼³' => 'á¼»',
		'á¼´' => 'á¼¼', 'á¼µ' => 'á¼½', 'á¼¶' => 'á¼¾', 'á¼·' => 'á¼¿', 'á½€' => 'á½ˆ', 'á½�' => 'á½‰',
		'á½‚' => 'á½Š', 'á½ƒ' => 'á½‹', 'á½„' => 'á½Œ', 'á½…' => 'á½�', 'á½‘' => 'á½™', 'á½“' => 'á½›',
		'á½•' => 'á½�', 'á½—' => 'á½Ÿ', 'á½ ' => 'á½¨', 'á½¡' => 'á½©', 'á½¢' => 'á½ª', 'á½£' => 'á½«',
		'á½¤' => 'á½¬', 'á½¥' => 'á½­', 'á½¦' => 'á½®', 'á½§' => 'á½¯', 'á¾€' => 'á¾ˆ', 'á¾�' => 'á¾‰',
		'á¾‚' => 'á¾Š', 'á¾ƒ' => 'á¾‹', 'á¾„' => 'á¾Œ', 'á¾…' => 'á¾�', 'á¾†' => 'á¾Ž', 'á¾‡' => 'á¾�',
		'á¾�' => 'á¾˜', 'á¾‘' => 'á¾™', 'á¾’' => 'á¾š', 'á¾“' => 'á¾›', 'á¾”' => 'á¾œ', 'á¾•' => 'á¾�',
		'á¾–' => 'á¾ž', 'á¾—' => 'á¾Ÿ', 'á¾ ' => 'á¾¨', 'á¾¡' => 'á¾©', 'á¾¢' => 'á¾ª', 'á¾£' => 'á¾«',
		'á¾¤' => 'á¾¬', 'á¾¥' => 'á¾­', 'á¾¦' => 'á¾®', 'á¾§' => 'á¾¯', 'á¾°' => 'á¾¸', 'á¾±' => 'á¾¹',
		'á¿�' => 'á¿˜', 'á¿‘' => 'á¿™', 'á¿ ' => 'á¿¨', 'á¿¡' => 'á¿©', 'â“�' => 'â’¶', 'â“‘' => 'â’·',
		'â“’' => 'â’¸', 'â““' => 'â’¹', 'â“”' => 'â’º', 'â“•' => 'â’»', 'â“–' => 'â’¼', 'â“—' => 'â’½',
		'â“˜' => 'â’¾', 'â“™' => 'â’¿', 'â“š' => 'â“€', 'â“›' => 'â“�', 'â“œ' => 'â“‚', 'â“�' => 'â“ƒ',
		'â“ž' => 'â“„', 'â“Ÿ' => 'â“…', 'â“ ' => 'â“†', 'â“¡' => 'â“‡', 'â“¢' => 'â“ˆ', 'â“£' => 'â“‰',
		'â“¤' => 'â“Š', 'â“¥' => 'â“‹', 'â“¦' => 'â“Œ', 'â“§' => 'â“�', 'â“¨' => 'â“Ž', 'â“©' => 'â“�',
		'ï½�' => 'ï¼¡', 'ï½‚' => 'ï¼¢', 'ï½ƒ' => 'ï¼£', 'ï½„' => 'ï¼¤', 'ï½…' => 'ï¼¥', 'ï½†' => 'ï¼¦',
		'ï½‡' => 'ï¼§', 'ï½ˆ' => 'ï¼¨', 'ï½‰' => 'ï¼©', 'ï½Š' => 'ï¼ª', 'ï½‹' => 'ï¼«', 'ï½Œ' => 'ï¼¬',
		'ï½�' => 'ï¼­', 'ï½Ž' => 'ï¼®', 'ï½�' => 'ï¼¯', 'ï½�' => 'ï¼°', 'ï½‘' => 'ï¼±', 'ï½’' => 'ï¼²',
		'ï½“' => 'ï¼³', 'ï½”' => 'ï¼´', 'ï½•' => 'ï¼µ', 'ï½–' => 'ï¼¶', 'ï½—' => 'ï¼·', 'ï½˜' => 'ï¼¸',
		'ï½™' => 'ï¼¹', 'ï½š' => 'ï¼º'
	);

	/**
	 * All lowercase UTF-8 characters not properly handled by [http://php.net/mb_strtoupper mb_strtoupper()] mapped to uppercase characters
	 *
	 * @var array
	 */
	static private $mb_lower_to_upper_fix = array(
		'É˜' => 'ÆŽ', 'Ç²' => 'Ç±', 'áƒ�' => 'á‚ ', 'áƒ‘' => 'á‚¡', 'áƒ’' => 'á‚¢', 'áƒ“' => 'á‚£',
		'áƒ”' => 'á‚¤', 'áƒ•' => 'á‚¥', 'áƒ–' => 'á‚¦', 'áƒ—' => 'á‚§', 'áƒ˜' => 'á‚¨', 'áƒ™' => 'á‚©',
		'áƒš' => 'á‚ª', 'áƒ›' => 'á‚«', 'áƒœ' => 'á‚¬', 'áƒ�' => 'á‚­', 'áƒž' => 'á‚®', 'áƒŸ' => 'á‚¯',
		'áƒ ' => 'á‚°', 'áƒ¡' => 'á‚±', 'áƒ¢' => 'á‚²', 'áƒ£' => 'á‚³', 'áƒ¤' => 'á‚´', 'áƒ¥' => 'á‚µ',
		'áƒ¦' => 'á‚¶', 'áƒ§' => 'á‚·', 'áƒ¨' => 'á‚¸', 'áƒ©' => 'á‚¹', 'áƒª' => 'á‚º', 'áƒ«' => 'á‚»',
		'áƒ¬' => 'á‚¼', 'áƒ­' => 'á‚½', 'áƒ®' => 'á‚¾', 'áƒ¯' => 'á‚¿', 'áƒ°' => 'áƒ€', 'áƒ±' => 'áƒ�',
		'áƒ²' => 'áƒ‚', 'áƒ³' => 'áƒƒ', 'áƒ´' => 'áƒ„', 'áƒµ' => 'áƒ…', 'â“�' => 'â’¶', 'â“‘' => 'â’·',
		'â“’' => 'â’¸', 'â““' => 'â’¹', 'â“”' => 'â’º', 'â“•' => 'â’»', 'â“–' => 'â’¼', 'â“—' => 'â’½',
		'â“˜' => 'â’¾', 'â“™' => 'â’¿', 'â“š' => 'â“€', 'â“›' => 'â“�', 'â“œ' => 'â“‚', 'â“�' => 'â“ƒ',
		'â“ž' => 'â“„', 'â“Ÿ' => 'â“…', 'â“ ' => 'â“†', 'â“¡' => 'â“‡', 'â“¢' => 'â“ˆ', 'â“£' => 'â“‰',
		'â“¤' => 'â“Š', 'â“¥' => 'â“‹', 'â“¦' => 'â“Œ', 'â“§' => 'â“�', 'â“¨' => 'â“Ž', 'â“©' => 'â“�'
	);

	/**
	 * All uppercase UTF-8 characters not properly handled by [http://php.net/mb_strtolower mb_strtolower()] mapped to lowercase characters
	 *
	 * @var array
	 */
	static private $mb_upper_to_lower_fix = array(
		'Ç�' => 'É˜', 'Ç…' => 'Ç†', 'Çˆ' => 'Ç‰', 'Ç‹' => 'ÇŒ', 'á‚ ' => 'áƒ�', 'á‚¡' => 'áƒ‘',
		'á‚¢' => 'áƒ’', 'á‚£' => 'áƒ“', 'á‚¤' => 'áƒ”', 'á‚¥' => 'áƒ•', 'á‚¦' => 'áƒ–', 'á‚§' => 'áƒ—',
		'á‚¨' => 'áƒ˜', 'á‚©' => 'áƒ™', 'á‚ª' => 'áƒš', 'á‚«' => 'áƒ›', 'á‚¬' => 'áƒœ', 'á‚­' => 'áƒ�',
		'á‚®' => 'áƒž', 'á‚¯' => 'áƒŸ', 'á‚°' => 'áƒ ', 'á‚±' => 'áƒ¡', 'á‚²' => 'áƒ¢', 'á‚³' => 'áƒ£',
		'á‚´' => 'áƒ¤', 'á‚µ' => 'áƒ¥', 'á‚¶' => 'áƒ¦', 'á‚·' => 'áƒ§', 'á‚¸' => 'áƒ¨', 'á‚¹' => 'áƒ©',
		'á‚º' => 'áƒª', 'á‚»' => 'áƒ«', 'á‚¼' => 'áƒ¬', 'á‚½' => 'áƒ­', 'á‚¾' => 'áƒ®', 'á‚¿' => 'áƒ¯',
		'áƒ€' => 'áƒ°', 'áƒ�' => 'áƒ±', 'áƒ‚' => 'áƒ²', 'áƒƒ' => 'áƒ³', 'áƒ„' => 'áƒ´', 'áƒ…' => 'áƒµ',
		'á¾ˆ' => 'á¾€', 'á¾‰' => 'á¾�', 'á¾Š' => 'á¾‚', 'á¾‹' => 'á¾ƒ', 'á¾Œ' => 'á¾„', 'á¾�' => 'á¾…',
		'á¾Ž' => 'á¾†', 'á¾�' => 'á¾‡', 'á¾˜' => 'á¾�', 'á¾™' => 'á¾‘', 'á¾š' => 'á¾’', 'á¾›' => 'á¾“',
		'á¾œ' => 'á¾”', 'á¾�' => 'á¾•', 'á¾ž' => 'á¾–', 'á¾Ÿ' => 'á¾—', 'á¾¨' => 'á¾ ', 'á¾©' => 'á¾¡',
		'á¾ª' => 'á¾¢', 'á¾«' => 'á¾£', 'á¾¬' => 'á¾¤', 'á¾­' => 'á¾¥', 'á¾®' => 'á¾¦', 'á¾¯' => 'á¾§',
		'â’¶' => 'â“�', 'â’·' => 'â“‘', 'â’¸' => 'â“’', 'â’¹' => 'â““', 'â’º' => 'â“”', 'â’»' => 'â“•',
		'â’¼' => 'â“–', 'â’½' => 'â“—', 'â’¾' => 'â“˜', 'â’¿' => 'â“™', 'â“€' => 'â“š', 'â“�' => 'â“›',
		'â“‚' => 'â“œ', 'â“ƒ' => 'â“�', 'â“„' => 'â“ž', 'â“…' => 'â“Ÿ', 'â“†' => 'â“ ', 'â“‡' => 'â“¡',
		'â“ˆ' => 'â“¢', 'â“‰' => 'â“£', 'â“Š' => 'â“¤', 'â“‹' => 'â“¥', 'â“Œ' => 'â“¦', 'â“�' => 'â“§',
		'â“Ž' => 'â“¨', 'â“�' => 'â“©'
	);

	/**
	 * All uppercase UTF-8 characters mapped to lowercase characters
	 *
	 * @var array
	 */
	static private $upper_to_lower = array(
		'A' => 'a', 'B' => 'b', 'C' => 'c', 'D' => 'd', 'E' => 'e', 'F' => 'f',
		'G' => 'g', 'H' => 'h', 'I' => 'i', 'J' => 'j', 'K' => 'k', 'L' => 'l',
		'M' => 'm', 'N' => 'n', 'O' => 'o', 'P' => 'p', 'Q' => 'q', 'R' => 'r',
		'S' => 's', 'T' => 't', 'U' => 'u', 'V' => 'v', 'W' => 'w', 'X' => 'x',
		'Y' => 'y', 'Z' => 'z', 'Ã€' => 'Ã ', 'Ã�' => 'Ã¡', 'Ã‚' => 'Ã¢', 'Ãƒ' => 'Ã£',
		'Ã„' => 'Ã¤', 'Ã…' => 'Ã¥', 'Ã†' => 'Ã¦', 'Ã‡' => 'Ã§', 'Ãˆ' => 'Ã¨', 'Ã‰' => 'Ã©',
		'ÃŠ' => 'Ãª', 'Ã‹' => 'Ã«', 'ÃŒ' => 'Ã¬', 'Ã�' => 'Ã­', 'ÃŽ' => 'Ã®', 'Ã�' => 'Ã¯',
		'Ã�' => 'Ã°', 'Ã‘' => 'Ã±', 'Ã’' => 'Ã²', 'Ã“' => 'Ã³', 'Ã”' => 'Ã´', 'Ã•' => 'Ãµ',
		'Ã–' => 'Ã¶', 'Ã˜' => 'Ã¸', 'Ã™' => 'Ã¹', 'Ãš' => 'Ãº', 'Ã›' => 'Ã»', 'Ãœ' => 'Ã¼',
		'Ã�' => 'Ã½', 'Ãž' => 'Ã¾', 'Ä€' => 'Ä�', 'Ä‚' => 'Äƒ', 'Ä„' => 'Ä…', 'Ä†' => 'Ä‡',
		'Äˆ' => 'Ä‰', 'ÄŠ' => 'Ä‹', 'ÄŒ' => 'Ä�', 'ÄŽ' => 'Ä�', 'Ä�' => 'Ä‘', 'Ä’' => 'Ä“',
		'Ä”' => 'Ä•', 'Ä–' => 'Ä—', 'Ä˜' => 'Ä™', 'Äš' => 'Ä›', 'Äœ' => 'Ä�', 'Äž' => 'ÄŸ',
		'Ä ' => 'Ä¡', 'Ä¢' => 'Ä£', 'Ä¤' => 'Ä¥', 'Ä¦' => 'Ä§', 'Ä¨' => 'Ä©', 'Äª' => 'Ä«',
		'Ä¬' => 'Ä­', 'Ä®' => 'Ä¯', 'Ä°' => 'i', 'Ä²' => 'Ä³', 'Ä´' => 'Äµ', 'Ä¶' => 'Ä·',
		'Ä¹' => 'Äº', 'Ä»' => 'Ä¼', 'Ä½' => 'Ä¾', 'Ä¿' => 'Å€', 'Å�' => 'Å‚', 'Åƒ' => 'Å„',
		'Å…' => 'Å†', 'Å‡' => 'Åˆ', 'ÅŠ' => 'Å‹', 'ÅŒ' => 'Å�', 'ÅŽ' => 'Å�', 'Å�' => 'Å‘',
		'Å’' => 'Å“', 'Å”' => 'Å•', 'Å–' => 'Å—', 'Å˜' => 'Å™', 'Åš' => 'Å›', 'Åœ' => 'Å�',
		'Åž' => 'ÅŸ', 'Å ' => 'Å¡', 'Å¢' => 'Å£', 'Å¤' => 'Å¥', 'Å¦' => 'Å§', 'Å¨' => 'Å©',
		'Åª' => 'Å«', 'Å¬' => 'Å­', 'Å®' => 'Å¯', 'Å°' => 'Å±', 'Å²' => 'Å³', 'Å´' => 'Åµ',
		'Å¶' => 'Å·', 'Å¸' => 'Ã¿', 'Å¹' => 'Åº', 'Å»' => 'Å¼', 'Å½' => 'Å¾', 'Æ�' => 'É“',
		'Æ‚' => 'Æƒ', 'Æ„' => 'Æ…', 'Æ†' => 'É”', 'Æ‡' => 'Æˆ', 'ÆŠ' => 'É—', 'Æ‹' => 'ÆŒ',
		'ÆŽ' => 'É˜', 'Æ�' => 'É™', 'Æ�' => 'É›', 'Æ‘' => 'Æ’', 'Æ“' => 'É ', 'Æ”' => 'É£',
		'Æ–' => 'É©', 'Æ—' => 'É¨', 'Æ˜' => 'Æ™', 'Æœ' => 'É¯', 'Æ�' => 'É²', 'ÆŸ' => 'Éµ',
		'Æ ' => 'Æ¡', 'Æ¢' => 'Æ£', 'Æ¤' => 'Æ¥', 'Æ§' => 'Æ¨', 'Æ©' => 'Êƒ', 'Æ¬' => 'Æ­',
		'Æ®' => 'Êˆ', 'Æ¯' => 'Æ°', 'Æ±' => 'ÊŠ', 'Æ²' => 'Ê‹', 'Æ³' => 'Æ´', 'Æµ' => 'Æ¶',
		'Æ·' => 'Ê’', 'Æ¸' => 'Æ¹', 'Æ¼' => 'Æ½', 'Ç„' => 'Ç†', 'Ç…' => 'Ç†', 'Ç‡' => 'Ç‰',
		'Çˆ' => 'Ç‰', 'ÇŠ' => 'ÇŒ', 'Ç‹' => 'ÇŒ', 'Ç�' => 'ÇŽ', 'Ç�' => 'Ç�', 'Ç‘' => 'Ç’',
		'Ç“' => 'Ç”', 'Ç•' => 'Ç–', 'Ç—' => 'Ç˜', 'Ç™' => 'Çš', 'Ç›' => 'Çœ', 'Çž' => 'ÇŸ',
		'Ç ' => 'Ç¡', 'Ç¢' => 'Ç£', 'Ç¤' => 'Ç¥', 'Ç¦' => 'Ç§', 'Ç¨' => 'Ç©', 'Çª' => 'Ç«',
		'Ç¬' => 'Ç­', 'Ç®' => 'Ç¯', 'Ç±' => 'Ç³', 'Ç´' => 'Çµ', 'Çº' => 'Ç»', 'Ç¼' => 'Ç½',
		'Ç¾' => 'Ç¿', 'È€' => 'È�', 'È‚' => 'Èƒ', 'È„' => 'È…', 'È†' => 'È‡', 'Èˆ' => 'È‰',
		'ÈŠ' => 'È‹', 'ÈŒ' => 'È�', 'ÈŽ' => 'È�', 'È�' => 'È‘', 'È’' => 'È“', 'È”' => 'È•',
		'È–' => 'È—', 'Î†' => 'Î¬', 'Îˆ' => 'Î­', 'Î‰' => 'Î®', 'ÎŠ' => 'Î¯', 'ÎŒ' => 'ÏŒ',
		'ÎŽ' => 'Ï�', 'Î�' => 'ÏŽ', 'Î‘' => 'Î±', 'Î’' => 'Î²', 'Î“' => 'Î³', 'Î”' => 'Î´',
		'Î•' => 'Îµ', 'Î–' => 'Î¶', 'Î—' => 'Î·', 'Î˜' => 'Î¸', 'Î™' => 'Î¹', 'Îš' => 'Îº',
		'Î›' => 'Î»', 'Îœ' => 'Î¼', 'Î�' => 'Î½', 'Îž' => 'Î¾', 'ÎŸ' => 'Î¿', 'Î ' => 'Ï€',
		'Î¡' => 'Ï�', 'Î£' => 'Ïƒ', 'Î¤' => 'Ï„', 'Î¥' => 'Ï…', 'Î¦' => 'Ï†', 'Î§' => 'Ï‡',
		'Î¨' => 'Ïˆ', 'Î©' => 'Ï‰', 'Îª' => 'ÏŠ', 'Î«' => 'Ï‹', 'Ï¢' => 'Ï£', 'Ï¤' => 'Ï¥',
		'Ï¦' => 'Ï§', 'Ï¨' => 'Ï©', 'Ïª' => 'Ï«', 'Ï¬' => 'Ï­', 'Ï®' => 'Ï¯', 'Ð�' => 'Ñ‘',
		'Ð‚' => 'Ñ’', 'Ðƒ' => 'Ñ“', 'Ð„' => 'Ñ”', 'Ð…' => 'Ñ•', 'Ð†' => 'Ñ–', 'Ð‡' => 'Ñ—',
		'Ðˆ' => 'Ñ˜', 'Ð‰' => 'Ñ™', 'ÐŠ' => 'Ñš', 'Ð‹' => 'Ñ›', 'ÐŒ' => 'Ñœ', 'ÐŽ' => 'Ñž',
		'Ð�' => 'ÑŸ', 'Ð�' => 'Ð°', 'Ð‘' => 'Ð±', 'Ð’' => 'Ð²', 'Ð“' => 'Ð³', 'Ð”' => 'Ð´',
		'Ð•' => 'Ðµ', 'Ð–' => 'Ð¶', 'Ð—' => 'Ð·', 'Ð˜' => 'Ð¸', 'Ð™' => 'Ð¹', 'Ðš' => 'Ðº',
		'Ð›' => 'Ð»', 'Ðœ' => 'Ð¼', 'Ð�' => 'Ð½', 'Ðž' => 'Ð¾', 'ÐŸ' => 'Ð¿', 'Ð ' => 'Ñ€',
		'Ð¡' => 'Ñ�', 'Ð¢' => 'Ñ‚', 'Ð£' => 'Ñƒ', 'Ð¤' => 'Ñ„', 'Ð¥' => 'Ñ…', 'Ð¦' => 'Ñ†',
		'Ð§' => 'Ñ‡', 'Ð¨' => 'Ñˆ', 'Ð©' => 'Ñ‰', 'Ðª' => 'ÑŠ', 'Ð«' => 'Ñ‹', 'Ð¬' => 'ÑŒ',
		'Ð­' => 'Ñ�', 'Ð®' => 'ÑŽ', 'Ð¯' => 'Ñ�', 'Ñ ' => 'Ñ¡', 'Ñ¢' => 'Ñ£', 'Ñ¤' => 'Ñ¥',
		'Ñ¦' => 'Ñ§', 'Ñ¨' => 'Ñ©', 'Ñª' => 'Ñ«', 'Ñ¬' => 'Ñ­', 'Ñ®' => 'Ñ¯', 'Ñ°' => 'Ñ±',
		'Ñ²' => 'Ñ³', 'Ñ´' => 'Ñµ', 'Ñ¶' => 'Ñ·', 'Ñ¸' => 'Ñ¹', 'Ñº' => 'Ñ»', 'Ñ¼' => 'Ñ½',
		'Ñ¾' => 'Ñ¿', 'Ò€' => 'Ò�', 'Ò�' => 'Ò‘', 'Ò’' => 'Ò“', 'Ò”' => 'Ò•', 'Ò–' => 'Ò—',
		'Ò˜' => 'Ò™', 'Òš' => 'Ò›', 'Òœ' => 'Ò�', 'Òž' => 'ÒŸ', 'Ò ' => 'Ò¡', 'Ò¢' => 'Ò£',
		'Ò¤' => 'Ò¥', 'Ò¦' => 'Ò§', 'Ò¨' => 'Ò©', 'Òª' => 'Ò«', 'Ò¬' => 'Ò­', 'Ò®' => 'Ò¯',
		'Ò°' => 'Ò±', 'Ò²' => 'Ò³', 'Ò´' => 'Òµ', 'Ò¶' => 'Ò·', 'Ò¸' => 'Ò¹', 'Òº' => 'Ò»',
		'Ò¼' => 'Ò½', 'Ò¾' => 'Ò¿', 'Ó�' => 'Ó‚', 'Óƒ' => 'Ó„', 'Ó‡' => 'Óˆ', 'Ó‹' => 'ÓŒ',
		'Ó�' => 'Ó‘', 'Ó’' => 'Ó“', 'Ó”' => 'Ó•', 'Ó–' => 'Ó—', 'Ó˜' => 'Ó™', 'Óš' => 'Ó›',
		'Óœ' => 'Ó�', 'Óž' => 'ÓŸ', 'Ó ' => 'Ó¡', 'Ó¢' => 'Ó£', 'Ó¤' => 'Ó¥', 'Ó¦' => 'Ó§',
		'Ó¨' => 'Ó©', 'Óª' => 'Ó«', 'Ó®' => 'Ó¯', 'Ó°' => 'Ó±', 'Ó²' => 'Ó³', 'Ó´' => 'Óµ',
		'Ó¸' => 'Ó¹', 'Ô±' => 'Õ¡', 'Ô²' => 'Õ¢', 'Ô³' => 'Õ£', 'Ô´' => 'Õ¤', 'Ôµ' => 'Õ¥',
		'Ô¶' => 'Õ¦', 'Ô·' => 'Õ§', 'Ô¸' => 'Õ¨', 'Ô¹' => 'Õ©', 'Ôº' => 'Õª', 'Ô»' => 'Õ«',
		'Ô¼' => 'Õ¬', 'Ô½' => 'Õ­', 'Ô¾' => 'Õ®', 'Ô¿' => 'Õ¯', 'Õ€' => 'Õ°', 'Õ�' => 'Õ±',
		'Õ‚' => 'Õ²', 'Õƒ' => 'Õ³', 'Õ„' => 'Õ´', 'Õ…' => 'Õµ', 'Õ†' => 'Õ¶', 'Õ‡' => 'Õ·',
		'Õˆ' => 'Õ¸', 'Õ‰' => 'Õ¹', 'ÕŠ' => 'Õº', 'Õ‹' => 'Õ»', 'ÕŒ' => 'Õ¼', 'Õ�' => 'Õ½',
		'ÕŽ' => 'Õ¾', 'Õ�' => 'Õ¿', 'Õ�' => 'Ö€', 'Õ‘' => 'Ö�', 'Õ’' => 'Ö‚', 'Õ“' => 'Öƒ',
		'Õ”' => 'Ö„', 'Õ•' => 'Ö…', 'Õ–' => 'Ö†', 'á‚ ' => 'áƒ�', 'á‚¡' => 'áƒ‘', 'á‚¢' => 'áƒ’',
		'á‚£' => 'áƒ“', 'á‚¤' => 'áƒ”', 'á‚¥' => 'áƒ•', 'á‚¦' => 'áƒ–', 'á‚§' => 'áƒ—', 'á‚¨' => 'áƒ˜',
		'á‚©' => 'áƒ™', 'á‚ª' => 'áƒš', 'á‚«' => 'áƒ›', 'á‚¬' => 'áƒœ', 'á‚­' => 'áƒ�', 'á‚®' => 'áƒž',
		'á‚¯' => 'áƒŸ', 'á‚°' => 'áƒ ', 'á‚±' => 'áƒ¡', 'á‚²' => 'áƒ¢', 'á‚³' => 'áƒ£', 'á‚´' => 'áƒ¤',
		'á‚µ' => 'áƒ¥', 'á‚¶' => 'áƒ¦', 'á‚·' => 'áƒ§', 'á‚¸' => 'áƒ¨', 'á‚¹' => 'áƒ©', 'á‚º' => 'áƒª',
		'á‚»' => 'áƒ«', 'á‚¼' => 'áƒ¬', 'á‚½' => 'áƒ­', 'á‚¾' => 'áƒ®', 'á‚¿' => 'áƒ¯', 'áƒ€' => 'áƒ°',
		'áƒ�' => 'áƒ±', 'áƒ‚' => 'áƒ²', 'áƒƒ' => 'áƒ³', 'áƒ„' => 'áƒ´', 'áƒ…' => 'áƒµ', 'á¸€' => 'á¸�',
		'á¸‚' => 'á¸ƒ', 'á¸„' => 'á¸…', 'á¸†' => 'á¸‡', 'á¸ˆ' => 'á¸‰', 'á¸Š' => 'á¸‹', 'á¸Œ' => 'á¸�',
		'á¸Ž' => 'á¸�', 'á¸�' => 'á¸‘', 'á¸’' => 'á¸“', 'á¸”' => 'á¸•', 'á¸–' => 'á¸—', 'á¸˜' => 'á¸™',
		'á¸š' => 'á¸›', 'á¸œ' => 'á¸�', 'á¸ž' => 'á¸Ÿ', 'á¸ ' => 'á¸¡', 'á¸¢' => 'á¸£', 'á¸¤' => 'á¸¥',
		'á¸¦' => 'á¸§', 'á¸¨' => 'á¸©', 'á¸ª' => 'á¸«', 'á¸¬' => 'á¸­', 'á¸®' => 'á¸¯', 'á¸°' => 'á¸±',
		'á¸²' => 'á¸³', 'á¸´' => 'á¸µ', 'á¸¶' => 'á¸·', 'á¸¸' => 'á¸¹', 'á¸º' => 'á¸»', 'á¸¼' => 'á¸½',
		'á¸¾' => 'á¸¿', 'á¹€' => 'á¹�', 'á¹‚' => 'á¹ƒ', 'á¹„' => 'á¹…', 'á¹†' => 'á¹‡', 'á¹ˆ' => 'á¹‰',
		'á¹Š' => 'á¹‹', 'á¹Œ' => 'á¹�', 'á¹Ž' => 'á¹�', 'á¹�' => 'á¹‘', 'á¹’' => 'á¹“', 'á¹”' => 'á¹•',
		'á¹–' => 'á¹—', 'á¹˜' => 'á¹™', 'á¹š' => 'á¹›', 'á¹œ' => 'á¹�', 'á¹ž' => 'á¹Ÿ', 'á¹ ' => 'á¹¡',
		'á¹¢' => 'á¹£', 'á¹¤' => 'á¹¥', 'á¹¦' => 'á¹§', 'á¹¨' => 'á¹©', 'á¹ª' => 'á¹«', 'á¹¬' => 'á¹­',
		'á¹®' => 'á¹¯', 'á¹°' => 'á¹±', 'á¹²' => 'á¹³', 'á¹´' => 'á¹µ', 'á¹¶' => 'á¹·', 'á¹¸' => 'á¹¹',
		'á¹º' => 'á¹»', 'á¹¼' => 'á¹½', 'á¹¾' => 'á¹¿', 'áº€' => 'áº�', 'áº‚' => 'áºƒ', 'áº„' => 'áº…',
		'áº†' => 'áº‡', 'áºˆ' => 'áº‰', 'áºŠ' => 'áº‹', 'áºŒ' => 'áº�', 'áºŽ' => 'áº�', 'áº�' => 'áº‘',
		'áº’' => 'áº“', 'áº”' => 'áº•', 'áº ' => 'áº¡', 'áº¢' => 'áº£', 'áº¤' => 'áº¥', 'áº¦' => 'áº§',
		'áº¨' => 'áº©', 'áºª' => 'áº«', 'áº¬' => 'áº­', 'áº®' => 'áº¯', 'áº°' => 'áº±', 'áº²' => 'áº³',
		'áº´' => 'áºµ', 'áº¶' => 'áº·', 'áº¸' => 'áº¹', 'áºº' => 'áº»', 'áº¼' => 'áº½', 'áº¾' => 'áº¿',
		'á»€' => 'á»�', 'á»‚' => 'á»ƒ', 'á»„' => 'á»…', 'á»†' => 'á»‡', 'á»ˆ' => 'á»‰', 'á»Š' => 'á»‹',
		'á»Œ' => 'á»�', 'á»Ž' => 'á»�', 'á»�' => 'á»‘', 'á»’' => 'á»“', 'á»”' => 'á»•', 'á»–' => 'á»—',
		'á»˜' => 'á»™', 'á»š' => 'á»›', 'á»œ' => 'á»�', 'á»ž' => 'á»Ÿ', 'á» ' => 'á»¡', 'á»¢' => 'á»£',
		'á»¤' => 'á»¥', 'á»¦' => 'á»§', 'á»¨' => 'á»©', 'á»ª' => 'á»«', 'á»¬' => 'á»­', 'á»®' => 'á»¯',
		'á»°' => 'á»±', 'á»²' => 'á»³', 'á»´' => 'á»µ', 'á»¶' => 'á»·', 'á»¸' => 'á»¹', 'á¼ˆ' => 'á¼€',
		'á¼‰' => 'á¼�', 'á¼Š' => 'á¼‚', 'á¼‹' => 'á¼ƒ', 'á¼Œ' => 'á¼„', 'á¼�' => 'á¼…', 'á¼Ž' => 'á¼†',
		'á¼�' => 'á¼‡', 'á¼˜' => 'á¼�', 'á¼™' => 'á¼‘', 'á¼š' => 'á¼’', 'á¼›' => 'á¼“', 'á¼œ' => 'á¼”',
		'á¼�' => 'á¼•', 'á¼¨' => 'á¼ ', 'á¼©' => 'á¼¡', 'á¼ª' => 'á¼¢', 'á¼«' => 'á¼£', 'á¼¬' => 'á¼¤',
		'á¼­' => 'á¼¥', 'á¼®' => 'á¼¦', 'á¼¯' => 'á¼§', 'á¼¸' => 'á¼°', 'á¼¹' => 'á¼±', 'á¼º' => 'á¼²',
		'á¼»' => 'á¼³', 'á¼¼' => 'á¼´', 'á¼½' => 'á¼µ', 'á¼¾' => 'á¼¶', 'á¼¿' => 'á¼·', 'á½ˆ' => 'á½€',
		'á½‰' => 'á½�', 'á½Š' => 'á½‚', 'á½‹' => 'á½ƒ', 'á½Œ' => 'á½„', 'á½�' => 'á½…', 'á½™' => 'á½‘',
		'á½›' => 'á½“', 'á½�' => 'á½•', 'á½Ÿ' => 'á½—', 'á½¨' => 'á½ ', 'á½©' => 'á½¡', 'á½ª' => 'á½¢',
		'á½«' => 'á½£', 'á½¬' => 'á½¤', 'á½­' => 'á½¥', 'á½®' => 'á½¦', 'á½¯' => 'á½§', 'á¾ˆ' => 'á¾€',
		'á¾‰' => 'á¾�', 'á¾Š' => 'á¾‚', 'á¾‹' => 'á¾ƒ', 'á¾Œ' => 'á¾„', 'á¾�' => 'á¾…', 'á¾Ž' => 'á¾†',
		'á¾�' => 'á¾‡', 'á¾˜' => 'á¾�', 'á¾™' => 'á¾‘', 'á¾š' => 'á¾’', 'á¾›' => 'á¾“', 'á¾œ' => 'á¾”',
		'á¾�' => 'á¾•', 'á¾ž' => 'á¾–', 'á¾Ÿ' => 'á¾—', 'á¾¨' => 'á¾ ', 'á¾©' => 'á¾¡', 'á¾ª' => 'á¾¢',
		'á¾«' => 'á¾£', 'á¾¬' => 'á¾¤', 'á¾­' => 'á¾¥', 'á¾®' => 'á¾¦', 'á¾¯' => 'á¾§', 'á¾¸' => 'á¾°',
		'á¾¹' => 'á¾±', 'á¿˜' => 'á¿�', 'á¿™' => 'á¿‘', 'á¿¨' => 'á¿ ', 'á¿©' => 'á¿¡', 'â’¶' => 'â“�',
		'â’·' => 'â“‘', 'â’¸' => 'â“’', 'â’¹' => 'â““', 'â’º' => 'â“”', 'â’»' => 'â“•', 'â’¼' => 'â“–',
		'â’½' => 'â“—', 'â’¾' => 'â“˜', 'â’¿' => 'â“™', 'â“€' => 'â“š', 'â“�' => 'â“›', 'â“‚' => 'â“œ',
		'â“ƒ' => 'â“�', 'â“„' => 'â“ž', 'â“…' => 'â“Ÿ', 'â“†' => 'â“ ', 'â“‡' => 'â“¡', 'â“ˆ' => 'â“¢',
		'â“‰' => 'â“£', 'â“Š' => 'â“¤', 'â“‹' => 'â“¥', 'â“Œ' => 'â“¦', 'â“�' => 'â“§', 'â“Ž' => 'â“¨',
		'â“�' => 'â“©', 'ï¼¡' => 'ï½�', 'ï¼¢' => 'ï½‚', 'ï¼£' => 'ï½ƒ', 'ï¼¤' => 'ï½„', 'ï¼¥' => 'ï½…',
		'ï¼¦' => 'ï½†', 'ï¼§' => 'ï½‡', 'ï¼¨' => 'ï½ˆ', 'ï¼©' => 'ï½‰', 'ï¼ª' => 'ï½Š', 'ï¼«' => 'ï½‹',
		'ï¼¬' => 'ï½Œ', 'ï¼­' => 'ï½�', 'ï¼®' => 'ï½Ž', 'ï¼¯' => 'ï½�', 'ï¼°' => 'ï½�', 'ï¼±' => 'ï½‘',
		'ï¼²' => 'ï½’', 'ï¼³' => 'ï½“', 'ï¼´' => 'ï½”', 'ï¼µ' => 'ï½•', 'ï¼¶' => 'ï½–', 'ï¼·' => 'ï½—',
		'ï¼¸' => 'ï½˜', 'ï¼¹' => 'ï½™', 'ï¼º' => 'ï½š'
	);

	/**
	 * A mapping of all ASCII-based latin characters, puntuation, symbols and number forms to ASCII.
	 *
	 * Includes elements form the following unicode blocks:
	 *
	 *  - Latin-1 Supplement
	 *  - Latin Extended-A
	 *  - Latin Extended-B
	 *  - IPA Extensions
	 *  - Latin Extended Additional
	 *  - General Punctuation
	 *  - Letterlike symbols
	 *  - Number Forms
	 *
	 * @var array
	 */
	static private $utf8_to_ascii = array(
		// Latin-1 Supplement
		'Â©' => '(c)', 'Â«' => '<<',  'Â®' => '(R)', 'Â»' => '>>',  'Â¼' => '1/4',
		'Â½' => '1/2', 'Â¾' => '3/4', 'Ã€' => 'A',   'Ã�' => 'A',   'Ã‚' => 'A',
		'Ãƒ' => 'A',   'Ã„' => 'A',   'Ã…' => 'A',   'Ã†' => 'AE',  'Ã‡' => 'C',
		'Ãˆ' => 'E',   'Ã‰' => 'E',   'ÃŠ' => 'E',   'Ã‹' => 'E',   'ÃŒ' => 'I',
		'Ã�' => 'I',   'ÃŽ' => 'I',   'Ã�' => 'I',   'Ã‘' => 'N',   'Ã’' => 'O',
		'Ã“' => 'O',   'Ã”' => 'O',   'Ã•' => 'O',   'Ã–' => 'O',   'Ã˜' => 'O',
		'Ã™' => 'U',   'Ãš' => 'U',   'Ã›' => 'U',   'Ãœ' => 'U',   'Ã�' => 'Y',
		'Ã ' => 'a',   'Ã¡' => 'a',   'Ã¢' => 'a',   'Ã£' => 'a',   'Ã¤' => 'a',
		'Ã¥' => 'a',   'Ã¦' => 'ae',  'Ã§' => 'c',   'Ã¨' => 'e',   'Ã©' => 'e',
		'Ãª' => 'e',   'Ã«' => 'e',   'Ã¬' => 'i',   'Ã­' => 'i',   'Ã®' => 'i',
		'Ã¯' => 'i',   'Ã±' => 'n',   'Ã²' => 'o',   'Ã³' => 'o',   'Ã´' => 'o',
		'Ãµ' => 'o',   'Ã¶' => 'o',   'Ã¸' => 'o',   'Ã¹' => 'u',   'Ãº' => 'u',
		'Ã»' => 'u',   'Ã¼' => 'u',   'Ã½' => 'y',   'Ã¿' => 'y',
		// Latin Extended-A
		'Ä€' => 'A',   'Ä�' => 'a',   'Ä‚' => 'A',   'Äƒ' => 'a',   'Ä„' => 'A',
		'Ä…' => 'a',   'Ä†' => 'C',   'Ä‡' => 'c',   'Äˆ' => 'C',   'Ä‰' => 'c',
		'ÄŠ' => 'C',   'Ä‹' => 'c',   'ÄŒ' => 'C',   'Ä�' => 'c',   'ÄŽ' => 'D',
		'Ä�' => 'd',   'Ä�' => 'D',   'Ä‘' => 'd',   'Ä’' => 'E',   'Ä“' => 'e',
		'Ä”' => 'E',   'Ä•' => 'e',   'Ä–' => 'E',   'Ä—' => 'e',   'Ä˜' => 'E',
		'Ä™' => 'e',   'Äš' => 'E',   'Ä›' => 'e',   'Äœ' => 'G',   'Ä�' => 'g',
		'Äž' => 'G',   'ÄŸ' => 'g',   'Ä ' => 'G',   'Ä¡' => 'g',   'Ä¢' => 'G',
		'Ä£' => 'g',   'Ä¤' => 'H',   'Ä¥' => 'h',   'Ä¦' => 'H',   'Ä§' => 'h',
		'Ä¨' => 'I',   'Ä©' => 'i',   'Äª' => 'I',   'Ä«' => 'i',   'Ä¬' => 'I',
		'Ä­' => 'i',   'Ä®' => 'I',   'Ä¯' => 'i',   'Ä°' => 'I',   'Ä±' => 'i',
		'Ä²' => 'IJ',  'Ä³' => 'ij',  'Ä´' => 'J',   'Äµ' => 'j',   'Ä¶' => 'K',
		'Ä·' => 'k',   'Ä¹' => 'L',   'Äº' => 'l',   'Ä»' => 'L',   'Ä¼' => 'l',
		'Ä½' => 'L',   'Ä¾' => 'l',   'Ä¿' => 'L',   'Å€' => 'l',   'Å�' => 'L',
		'Å‚' => 'l',   'Åƒ' => 'N',   'Å„' => 'n',   'Å…' => 'N',   'Å†' => 'n',
		'Å‡' => 'N',   'Åˆ' => 'n',   'Å‰' => "'n", 'ÅŠ' => 'N',   'Å‹' => 'n',
		'ÅŒ' => 'O',   'Å�' => 'o',   'ÅŽ' => 'O',   'Å�' => 'o',   'Å�' => 'O',
		'Å‘' => 'o',   'Å’' => 'OE',  'Å“' => 'oe',  'Å”' => 'R',   'Å•' => 'r',
		'Å–' => 'R',   'Å—' => 'r',   'Å˜' => 'R',   'Å™' => 'r',   'Åš' => 'S',
		'Å›' => 's',   'Åœ' => 'S',   'Å�' => 's',   'Åž' => 'S',   'ÅŸ' => 's',
		'Å ' => 'S',   'Å¡' => 's',   'Å¢' => 'T',   'Å£' => 't',   'Å¤' => 'T',
		'Å¥' => 't',   'Å¦' => 'T',   'Å§' => 't',   'Å¨' => 'U',   'Å©' => 'u',
		'Åª' => 'U',   'Å«' => 'u',   'Å¬' => 'U',   'Å­' => 'u',   'Å®' => 'U',
		'Å¯' => 'u',   'Å°' => 'U',   'Å±' => 'u',   'Å²' => 'U',   'Å³' => 'u',
		'Å´' => 'W',   'Åµ' => 'w',   'Å¶' => 'Y',   'Å·' => 'y',   'Å¸' => 'Y',
		'Å¹' => 'Z',   'Åº' => 'z',   'Å»' => 'Z',   'Å¼' => 'z',   'Å½' => 'Z',
		'Å¾' => 'z',
		// Latin Extended-B
		'Æ€' => 'b',   'Æ�' => 'B',   'Æ‚' => 'B',   'Æƒ' => 'b',   'Æ†' => 'O',
		'Æ‡' => 'C',   'Æˆ' => 'c',   'Æ‰' => 'D',   'ÆŠ' => 'D',   'Æ‹' => 'D',
		'ÆŒ' => 'd',   'ÆŽ' => 'E',   'Æ�' => 'E',   'Æ‘' => 'F',   'Æ’' => 'f',
		'Æ“' => 'G',   'Æ—' => 'I',   'Æ˜' => 'K',   'Æ™' => 'k',   'Æš' => 'l',
		'Æœ' => 'M',   'Æ�' => 'N',   'Æž' => 'n',   'ÆŸ' => 'O',   'Æ ' => 'O',
		'Æ¡' => 'o',   'Æ¢' => 'OI',  'Æ£' => 'oi',  'Æ¤' => 'P',   'Æ¥' => 'p',
		'Æ«' => 't',   'Æ¬' => 'T',   'Æ­' => 't',   'Æ®' => 'T',   'Æ¯' => 'U',
		'Æ°' => 'u',   'Æ²' => 'V',   'Æ³' => 'Y',   'Æ´' => 'y',   'Æµ' => 'Z',
		'Æ¶' => 'z',   'Æ»' => '2',   'Ç„' => 'DZ',  'Ç…' => 'Dz',  'Ç†' => 'dz',
		'Ç‡' => 'LJ',  'Çˆ' => 'Lj',  'Ç‰' => 'lj',  'ÇŠ' => 'Nj',  'Ç‹' => 'Nj',
		'ÇŒ' => 'nj',  'Ç�' => 'A',   'ÇŽ' => 'a',   'Ç�' => 'I',   'Ç�' => 'i',
		'Ç‘' => 'O',   'Ç’' => 'o',   'Ç“' => 'U',   'Ç”' => 'u',   'Ç•' => 'U',
		'Ç–' => 'u',   'Ç—' => 'U',   'Ç˜' => 'u',   'Ç™' => 'U',   'Çš' => 'u',
		'Ç›' => 'U',   'Çœ' => 'u',   'Ç�' => 'e',   'Çž' => 'A',   'ÇŸ' => 'a',
		'Ç ' => 'A',   'Ç¡' => 'a',   'Ç¢' => 'AE',  'Ç£' => 'ae',  'Ç¤' => 'G',
		'Ç¥' => 'g',   'Ç¦' => 'G',   'Ç§' => 'g',   'Ç¨' => 'K',   'Ç©' => 'k',
		'Çª' => 'O',   'Ç«' => 'o',   'Ç¬' => 'O',   'Ç­' => 'o',   'Ç°' => 'j',
		'Ç±' => 'DZ',  'Ç²' => 'Dz',  'Ç³' => 'dz',  'Ç´' => 'G',   'Çµ' => 'g',
		'Ç¸' => 'N',   'Ç¹' => 'n',   'Çº' => 'A',   'Ç»' => 'a',   'Ç¼' => 'AE',
		'Ç½' => 'ae',  'Ç¾' => 'O',   'Ç¿' => 'o',   'È€' => 'A',   'È�' => 'a',
		'È‚' => 'A',   'Èƒ' => 'a',   'È„' => 'E',   'È…' => 'e',   'È†' => 'E',
		'È‡' => 'e',   'Èˆ' => 'I',   'È‰' => 'i',   'ÈŠ' => 'I',   'È‹' => 'i',
		'ÈŒ' => 'O',   'È�' => 'o',   'ÈŽ' => 'O',   'È�' => 'o',   'È�' => 'R',
		'È‘' => 'r',   'È’' => 'R',   'È“' => 'r',   'È”' => 'U',   'È•' => 'u',
		'È–' => 'U',   'È—' => 'u',   'È˜' => 'S',   'È™' => 's',   'Èš' => 'T',
		'È›' => 't',   'Èž' => 'H',   'ÈŸ' => 'h',   'È ' => 'N',   'È¡' => 'd',
		'È¤' => 'Z',   'È¥' => 'z',   'È¦' => 'A',   'È§' => 'a',   'È¨' => 'E',
		'È©' => 'e',   'Èª' => 'O',   'È«' => 'o',   'È¬' => 'O',   'È­' => 'o',
		'È®' => 'O',   'È¯' => 'o',   'È°' => 'O',   'È±' => 'o',   'È²' => 'Y',
		'È³' => 'y',   'È´' => 'l',   'Èµ' => 'n',   'È¶' => 't',   'È·' => 'j',
		'È¸' => 'db',  'È¹' => 'qp',  'Èº' => 'A',   'È»' => 'C',   'È¼' => 'c',
		'È½' => 'L',   'È¾' => 'T',   'È¿' => 's',   'É€' => 'z',   'Éƒ' => 'B',
		'É„' => 'U',   'É…' => 'V',   'É†' => 'E',   'É‡' => 'e',   'Éˆ' => 'J',
		'É‰' => 'j',   'ÉŠ' => 'Q',   'É‹' => 'q',   'ÉŒ' => 'R',   'É�' => 'r',
		'ÉŽ' => 'Y',   'É�' => 'y',
		// IPA Extensions
		'É�' => 'a',   'É“' => 'b',   'É”' => 'o',   'É•' => 'c',   'É–' => 'd',
		'É—' => 'd',   'É˜' => 'e',   'É›' => 'e',   'Éœ' => 'e',   'É�' => 'e',
		'Éž' => 'e',   'ÉŸ' => 'j',   'É ' => 'g',   'É¡' => 'g',   'É¢' => 'G',
		'É¥' => 'h',   'É¦' => 'h',   'É¨' => 'i',   'Éª' => 'I',   'É«' => 'l',
		'É¬' => 'l',   'É­' => 'l',   'É¯' => 'm',   'É°' => 'm',   'É±' => 'm',
		'É²' => 'n',   'É³' => 'n',   'É´' => 'N',   'Éµ' => 'o',   'É¶' => 'OE',
		'É¹' => 'r',   'Éº' => 'r',   'É»' => 'r',   'É¼' => 'r',   'É½' => 'r',
		'É¾' => 'r',   'É¿' => 'r',   'Ê€' => 'R',   'Ê�' => 'R',   'Ê‚' => 's',
		'Ê‡' => 't',   'Êˆ' => 't',   'Ê‰' => 'u',   'Ê‹' => 'v',   'ÊŒ' => 'v',
		'Ê�' => 'w',   'ÊŽ' => 'y',   'Ê�' => 'Y',   'Ê�' => 'z',   'Ê‘' => 'z',
		'Ê—' => 'C',   'Ê™' => 'B',   'Êš' => 'e',   'Ê›' => 'G',   'Êœ' => 'H',
		'Ê�' => 'j',   'Êž' => 'k',   'ÊŸ' => 'L',   'Ê ' => 'q',   'Ê£' => 'dz',
		'Ê¥' => 'dz',  'Ê¦' => 'ts',  'Ê¨' => 'tc',  'Êª' => 'ls',  'Ê«' => 'lz',
		'Ê®' => 'h',   'Ê¯' => 'h',
		// Latin Extended Additional
		'á¸€' => 'A',   'á¸�' => 'a',   'á¸‚' => 'B',   'á¸ƒ' => 'b',   'á¸„' => 'B',
		'á¸…' => 'b',   'á¸†' => 'B',   'á¸‡' => 'b',   'á¸ˆ' => 'C',   'á¸‰' => 'c',
		'á¸Š' => 'D',   'á¸‹' => 'd',   'á¸Œ' => 'D',   'á¸�' => 'd',   'á¸Ž' => 'D',
		'á¸�' => 'd',   'á¸�' => 'D',   'á¸‘' => 'd',   'á¸’' => 'D',   'á¸“' => 'd',
		'á¸”' => 'E',   'á¸•' => 'e',   'á¸–' => 'E',   'á¸—' => 'e',   'á¸˜' => 'E',
		'á¸™' => 'e',   'á¸š' => 'E',   'á¸›' => 'e',   'á¸œ' => 'E',   'á¸�' => 'e',
		'á¸ž' => 'F',   'á¸Ÿ' => 'f',   'á¸ ' => 'G',   'á¸¡' => 'g',   'á¸¢' => 'H',
		'á¸£' => 'h',   'á¸¤' => 'H',   'á¸¥' => 'h',   'á¸¦' => 'H',   'á¸§' => 'h',
		'á¸¨' => 'H',   'á¸©' => 'h',   'á¸ª' => 'H',   'á¸«' => 'h',   'á¸¬' => 'I',
		'á¸­' => 'i',   'á¸®' => 'I',   'á¸¯' => 'i',   'á¸°' => 'K',   'á¸±' => 'k',
		'á¸²' => 'K',   'á¸³' => 'k',   'á¸´' => 'K',   'á¸µ' => 'k',   'á¸¶' => 'L',
		'á¸·' => 'l',   'á¸¸' => 'L',   'á¸¹' => 'l',   'á¸º' => 'L',   'á¸»' => 'l',
		'á¸¼' => 'L',   'á¸½' => 'l',   'á¸¾' => 'M',   'á¸¿' => 'm',   'á¹€' => 'M',
		'á¹�' => 'm',   'á¹‚' => 'M',   'á¹ƒ' => 'm',   'á¹„' => 'N',   'á¹…' => 'n',
		'á¹†' => 'N',   'á¹‡' => 'n',   'á¹ˆ' => 'N',   'á¹‰' => 'n',   'á¹Š' => 'N',
		'á¹‹' => 'n',   'á¹Œ' => 'O',   'á¹�' => 'o',   'á¹Ž' => 'O',   'á¹�' => 'o',
		'á¹�' => 'O',   'á¹‘' => 'o',   'á¹’' => 'O',   'á¹“' => 'o',   'á¹”' => 'P',
		'á¹•' => 'p',   'á¹–' => 'P',   'á¹—' => 'p',   'á¹˜' => 'R',   'á¹™' => 'r',
		'á¹š' => 'R',   'á¹›' => 'r',   'á¹œ' => 'R',   'á¹�' => 'r',   'á¹ž' => 'R',
		'á¹Ÿ' => 'r',   'á¹ ' => 'S',   'á¹¡' => 's',   'á¹¢' => 'S',   'á¹£' => 's',
		'á¹¤' => 'S',   'á¹¥' => 's',   'á¹¦' => 'S',   'á¹§' => 's',   'á¹¨' => 'S',
		'á¹©' => 's',   'á¹ª' => 'T',   'á¹«' => 't',   'á¹¬' => 'T',   'á¹­' => 't',
		'á¹®' => 'T',   'á¹¯' => 't',   'á¹°' => 'T',   'á¹±' => 't',   'á¹²' => 'U',
		'á¹³' => 'u',   'á¹´' => 'U',   'á¹µ' => 'u',   'á¹¶' => 'U',   'á¹·' => 'u',
		'á¹¸' => 'U',   'á¹¹' => 'u',   'á¹º' => 'U',   'á¹»' => 'u',   'á¹¼' => 'V',
		'á¹½' => 'v',   'á¹¾' => 'V',   'á¹¿' => 'v',   'áº€' => 'W',   'áº�' => 'w',
		'áº‚' => 'W',   'áºƒ' => 'w',   'áº„' => 'W',   'áº…' => 'w',   'áº†' => 'W',
		'áº‡' => 'w',   'áºˆ' => 'W',   'áº‰' => 'w',   'áºŠ' => 'X',   'áº‹' => 'x',
		'áºŒ' => 'X',   'áº�' => 'x',   'áºŽ' => 'Y',   'áº�' => 'y',   'áº�' => 'Z',
		'áº‘' => 'z',   'áº’' => 'Z',   'áº“' => 'z',   'áº”' => 'Z',   'áº•' => 'z',
		'áº–' => 'h',   'áº—' => 't',   'áº˜' => 'w',   'áº™' => 'y',   'áºš' => 'a',
		'áº ' => 'A',   'áº¡' => 'a',   'áº¢' => 'A',   'áº£' => 'a',   'áº¤' => 'A',
		'áº¥' => 'a',   'áº¦' => 'A',   'áº§' => 'a',   'áº¨' => 'A',   'áº©' => 'a',
		'áºª' => 'A',   'áº«' => 'a',   'áº¬' => 'A',   'áº­' => 'a',   'áº®' => 'A',
		'áº¯' => 'a',   'áº°' => 'A',   'áº±' => 'a',   'áº²' => 'A',   'áº³' => 'a',
		'áº´' => 'A',   'áºµ' => 'a',   'áº¶' => 'A',   'áº·' => 'a',   'áº¸' => 'E',
		'áº¹' => 'e',   'áºº' => 'E',   'áº»' => 'e',   'áº¼' => 'E',   'áº½' => 'e',
		'áº¾' => 'E',   'áº¿' => 'e',   'á»€' => 'E',   'á»�' => 'e',   'á»‚' => 'E',
		'á»ƒ' => 'e',   'á»„' => 'E',   'á»…' => 'e',   'á»†' => 'E',   'á»‡' => 'e',
		'á»ˆ' => 'I',   'á»‰' => 'i',   'á»Š' => 'I',   'á»‹' => 'i',   'á»Œ' => 'O',
		'á»�' => 'o',   'á»Ž' => 'O',   'á»�' => 'o',   'á»�' => 'O',   'á»‘' => 'o',
		'á»’' => 'O',   'á»“' => 'o',   'á»”' => 'O',   'á»•' => 'o',   'á»–' => 'O',
		'á»—' => 'o',   'á»˜' => 'O',   'á»™' => 'o',   'á»š' => 'O',   'á»›' => 'o',
		'á»œ' => 'O',   'á»�' => 'o',   'á»ž' => 'O',   'á»Ÿ' => 'o',   'á» ' => 'O',
		'á»¡' => 'o',   'á»¢' => 'O',   'á»£' => 'o',   'á»¤' => 'U',   'á»¥' => 'u',
		'á»¦' => 'U',   'á»§' => 'u',   'á»¨' => 'U',   'á»©' => 'u',   'á»ª' => 'U',
		'á»«' => 'u',   'á»¬' => 'U',   'á»­' => 'u',   'á»®' => 'U',   'á»¯' => 'u',
		'á»°' => 'U',   'á»±' => 'u',   'á»²' => 'Y',   'á»³' => 'y',   'á»´' => 'Y',
		'á»µ' => 'y',   'á»¶' => 'Y',   'á»·' => 'y',   'á»¸' => 'Y',   'á»¹' => 'y',
		// General Punctuation
		'â€€' => ' ',   'â€�' => ' ',   'â€‚' => ' ',   'â€ƒ' => ' ',   'â€„' => ' ',
		'â€…' => ' ',   'â€†' => ' ',   'â€‡' => ' ',   'â€ˆ' => ' ',   'â€‰' => ' ',
		'â€Š' => ' ',   'â€‹' => '',    'â€Œ' => '',    'â€�' => '',    'â€�' => '-',
		'â€‘' => '-',   'â€’' => '-',   'â€“' => '-',   'â€”' => '-',   'â€•' => '-',
		'â€–' => '||',  'â€˜' => "'",   'â€™' => "'",   'â€š' => ',',   'â€›' => "'",
		'â€œ' => '"',   'â€�' => '"',   'â€Ÿ' => '"',   'â€¤' => '.',   'â€¥' => '..',
		'â€¦' => '...', 'â€¯' => ' ',   'â€²' => "'",   'â€³' => '"',   'â€´' => '\'"',
		'â€µ' => "'",   'â€¶' => '"',   'â€·' => '"\'', 'â€¹' => '<',   'â€º' => '>',
		'â€¼' => '!!',  'â€½' => '?!',  'â�„' => '/',   'â�‡' => '?/',  'â�ˆ' => '?!',
		'â�‰' => '!?',
		// Letterlike Symbols
		'â„ ' => 'SM',  'â„¢' => 'TM',
		// Number Forms
		'â…“' => '1/3', 'â…”' => '2/3', 'â…•' => '1/5', 'â…–' => '2/5', 'â…—' => '3/5',
		'â…˜' => '4/5', 'â…™' => '1/6', 'â…š' => '5/6', 'â…›' => '1/8', 'â…œ' => '3/8',
		'â…�' => '5/8', 'â…ž' => '7/8', 'â… ' => 'I',   'â…¡' => 'II',  'â…¢' => 'III',
		'â…£' => 'IV',  'â…¤' => 'V',   'â…¥' => 'Vi',  'â…¦' => 'VII', 'â…§' => 'VIII',
		'â…¨' => 'IX',  'â…©' => 'X',   'â…ª' => 'XI',  'â…«' => 'XII', 'â…¬' => 'L',
		'â…­' => 'C',   'â…®' => 'D',   'â…¯' => 'M',   'â…°' => 'i',   'â…±' => 'ii',
		'â…²' => 'iii', 'â…³' => 'iv',  'â…´' => 'v',   'â…µ' => 'vi',  'â…¶' => 'vii',
		'â…·' => 'viii','â…¸' => 'ix',  'â…¹' => 'x',   'â…º' => 'xi',  'â…»' => 'xii',
		'â…¼' => 'l',   'â…½' => 'c',   'â…¾' => 'd',   'â…¿' => 'm'
	);

	/**
	 * If the [http://php.net/mbstring mbstring] extension is available
	 *
	 * @var boolean
	 */
	static private $mbstring_available = NULL;


	/**
	 * Maps UTF-8 ASCII-based latin characters, puntuation, symbols and number forms to ASCII
	 *
	 * Any characters or symbols that can not be translated will be removed.
	 *
	 * This function is most useful for situation that only allows ASCII, such
	 * as in URLs.
	 *
	 * Translates elements form the following unicode blocks:
	 *
	 *  - Latin-1 Supplement
	 *  - Latin Extended-A
	 *  - Latin Extended-B
	 *  - IPA Extensions
	 *  - Latin Extended Additional
	 *  - General Punctuation
	 *  - Letterlike symbols
	 *  - Number Forms
	 *
	 * @internal
	 *
	 * @param  string $string  The string to convert
	 * @return string  The input string in pure ASCII
	 */
	static public function ascii($string)
	{
		if (!self::detect($string)) {
			return $string;
		}

		$string = strtr($string, self::$utf8_to_ascii);
		return preg_replace('#[^\x00-\x7F]#', '', $string);
	}


	/**
	 * Checks to see if the [http://php.net/mbstring mbstring] extension is available
	 *
	 * @return void
	 */
	static private function checkMbString()
	{
		self::$mbstring_available = extension_loaded('mbstring');
	}


	/**
	 * Converts a unicode value into a UTF-8 character
	 *
	 * @param  mixed $unicode_code_point  The character to create, either the `U+hex` or decimal code point
	 * @return string  The UTF-8 character
	 */
	static public function chr($unicode_code_point)
	{
		if (is_string($unicode_code_point) && substr($unicode_code_point, 0, 2) == 'U+') {
			$unicode_code_point = substr($unicode_code_point, 2);
			$unicode_code_point = hexdec($unicode_code_point);
		}

		$bin = decbin($unicode_code_point);
		$digits = strlen($bin);

		$first = $second = $third = $fourth = NULL;

		// One byte characters
		if ($digits <= 7) {
			$first = chr(bindec($bin));

		// Two byte characters
		} elseif ($digits <= 11) {
			$first  = chr(bindec('110' . str_pad(substr($bin, 0, -6), 5, '0', STR_PAD_LEFT)));
			$second = chr(bindec('10' . substr($bin, -6)));

		// Three byte characters
		} elseif ($digits <= 16) {
			$first  = chr(bindec('1110' . str_pad(substr($bin, 0, -12), 4, '0', STR_PAD_LEFT)));
			$second = chr(bindec('10' . substr($bin, -12, -6)));
			$third  = chr(bindec('10' . substr($bin, -6)));

		// Four byte characters
		} elseif ($digits <= 21) {
			$first  = chr(bindec('11110' . str_pad(substr($bin, 0, -18), 3, '0', STR_PAD_LEFT)));
			$second = chr(bindec('10' . substr($bin, -18, -12)));
			$third  = chr(bindec('10' . substr($bin, -12, -6)));
			$fourth = chr(bindec('10' . substr($bin, -6)));
		}

		$ord = ord($first);
		if ($digits > 21 || $ord == 0xC0 || $ord == 0xC1 || $ord > 0xF4) {
			throw new \Exception(
				'The code point specified, %s, is invalid.',
				$unicode_code_point
			);
		}

		return $first . $second . $third . $fourth;
	}


	/**
	 * Removes any invalid UTF-8 characters from a string or array of strings
	 *
	 * @param  array|string $value  The string or array of strings to clean
	 * @return string  The cleaned string
	 */
	static public function clean($value)
	{
		if (!is_array($value)) {
			if (self::$can_ignore_invalid === NULL) {
				self::$can_ignore_invalid = !in_array(strtolower(ICONV_IMPL), array('unknown', 'ibm iconv'));	
			}
			$value = self::iconv('UTF-8', 'UTF-8' . (self::$can_ignore_invalid ? '//IGNORE' : ''), (string) $value);
			return $value;
		}

		$keys = array_keys($value);
		$num_keys = sizeof($keys);
		for ($i=0; $i<$num_keys; $i++) {
			$value[$keys[$i]] = self::clean($value[$keys[$i]]);
		}

		return $value;
	}


	/**
	 * Compares strings, with the resulting order having latin characters that are based on ASCII letters placed after the relative ASCII characters
	 *
	 * Please note that this function sorts based on English language sorting
	 * rules only. Locale-sepcific sorting is done by
	 * [http://php.net/strcoll strcoll()], however there are technical
	 * limitations.
	 *
	 * @param  string $str1  The first string to compare
	 * @param  string $str2  The second string to compare
	 * @return integer  < 0 if $str1 < $str2, 0 if they are equal, > 0 if $str1 > $str2
	 */
	static public function cmp($str1, $str2)
	{
		$ascii_str1 = strtr($str1, self::$utf8_to_ascii);
		$ascii_str2 = strtr($str2, self::$utf8_to_ascii);

		$res = strcmp($ascii_str1, $ascii_str2);

		// If the ASCII representations are the same, sort by the UTF-8 representations
		if ($res === 0) {
			$res = strcmp($str1, $str2);
		}

		return $res;
	}


	/**
	 * Converts an offset in characters to an offset in bytes to that we can use the built-in functions for some operations
	 *
	 * @param  string  $string  The string to base the offset on
	 * @param  integer $offset  The character offset to conver to bytes
	 * @return integer  The converted offset
	 */
	static private function convertOffsetToBytes($string, $offset)
	{
		if ($offset == 0) {
			return 0;
		}

		$len = strlen($string);

		$byte_offset     = 0;
		$measured_offset = 0;
		$sign            = 1;

		// Negative offsets require us to reverse some stuff
		if ($offset < 0) {
			$string    = strrev($string);
			$sign      = -1;
			$offset    = abs($offset);
		}

		for ($i=0; $i<$len && $measured_offset<$offset; $i++) {
			$char = $string[$i];
			++$byte_offset;
			if (ord($char) < 0x80) {
				++$measured_offset;
			} else {
				switch (ord($char) & 0xF0) {
					case 0xF0:
					case 0xE0:
					case 0xD0:
					case 0xC0:
						++$measured_offset;
						break;
				}
			}
		}

		return $byte_offset * $sign;
	}


	/**
	 * Detects if a UTF-8 string contains any non-ASCII characters
	 *
	 * @param  string $string  The string to check
	 * @return boolean  If the string contains any non-ASCII characters
	 */
	static private function detect($string)
	{
		return (boolean) preg_match('#[^\x00-\x7F]#', $string);
	}


	/**
	 * Explodes a string on a delimiter
	 *
	 * If no delimiter is provided, the string will be exploded with each
	 * characters being an element in the array.
	 *
	 * @param  string  $string     The string to explode
	 * @param  string  $delimiter  The string to explode on. If `NULL` or `''` this method will return one character per array index.
	 * @return array  The exploded string
	 */
	static public function explode($string, $delimiter=NULL)
	{
		// If a delimiter was passed, we just do an explode
		if ($delimiter || (!$delimiter && is_numeric($delimiter))) {
			return explode($delimiter, $string);
		}

		// If no delimiter was passed, we explode the characters into an array
		preg_match_all('#.|^\z#us', $string, $matches);
		return $matches[0];
	}


	/**
	 * This works around a bug in MAMP 1.9.4+ and PHP 5.3 where iconv()
	 * does not seem to properly assign the return value to a variable, but
	 * does work when returning the value.
	 *
	 * @param string $in_charset   The incoming character encoding
	 * @param string $out_charset  The outgoing character encoding
	 * @param string $string       The string to convert
	 * @return string  The converted string
	 */
	static private function iconv($in_charset, $out_charset, $string)
	{
		return @iconv($in_charset, $out_charset, $string);
	}
	
	
	/**
	 * Compares strings in a case-insensitive manner, with the resulting order having characters that are based on ASCII letters placed after the relative ASCII characters
	 *
	 * Please note that this function sorts based on English language sorting
	 * rules only. Locale-sepcific sorting is done by
	 * [http://php.net/strcoll strcoll()], however there are technical
	 * limitations.
	 *
	 * @param  string $str1  The first string to compare
	 * @param  string $str2  The second string to compare
	 * @return integer  < 0 if $str1 < $str2, 0 if they are equal, > 0 if $str1 > $str2
	 */
	static public function icmp($str1, $str2)
	{
		$str1 = self::lower($str1);
		$str2 = self::lower($str2);

		return self::cmp($str1, $str2);
	}


	/**
	 * Compares strings using a natural order algorithm in a case-insensitive manner, with the resulting order having latin characters that are based on ASCII letters placed after the relative ASCII characters
	 *
	 * Please note that this function sorts based on English language sorting
	 * rules only. Locale-sepcific sorting is done by
	 * [http://php.net/strcoll strcoll()], however there are technical
	 * limitations.
	 *
	 * @param  string $str1  The first string to compare
	 * @param  string $str2  The second string to compare
	 * @return integer  `< 0` if `$str1 < $str2`, `0` if they are equal, `> 0` if `$str1 > $str2`
	 */
	static public function inatcmp($str1, $str2)
	{
		$str1 = self::lower($str1);
		$str2 = self::lower($str2);

		return self::natcmp($str1, $str2);
	}


	/**
	 * Finds the first position (in characters) of the search value in the string - case is ignored when doing performing a match
	 *
	 * @param  string  $haystack  The string to search in
	 * @param  string  $needle    The string to search for. This match will be done in a case-insensitive manner.
	 * @param  integer $offset    The character position to start searching from
	 * @return mixed  The integer character position of the first occurence of the needle or `FALSE` if no match
	 */
	static public function ipos($haystack, $needle, $offset=0)
	{
		// We get better performance falling back for ASCII strings
		if (!self::detect($haystack)) {
			return stripos($haystack, $needle, $offset);
		}

		if (self::$mbstring_available === NULL) {
			self::checkMbString();
		}

		if (self::$mbstring_available && function_exists('mb_stripos')) {
			return mb_stripos($haystack, $needle, $offset, 'UTF-8');
		}

		$haystack = self::lower($haystack);
		$needle   = self::lower($needle);

		return self::pos($haystack, $needle, $offset);
	}


	/**
	 * Replaces matching parts of the string, with matches being done in a a case-insensitive manner
	 *
	 * If `$search` and `$replace` are both arrays and `$replace` is shorter,
	 * the extra `$search` string will be replaced with an empty string. If
	 * `$search` is an array and `$replace` is a string, all `$search` values
	 * will be replaced with the string specified.
	 *
	 * @param  string $string   The string to perform the replacements on
	 * @param  mixed  $search   The string (or array of strings) to search for - see method description for details
	 * @param  mixed  $replace  The string (or array of strings) to replace with - see method description for details
	 * @return string  The input string with the specified replacements
	 */
	static public function ireplace($string, $search, $replace)
	{
		if (is_array($search)) {
			foreach ($search as &$needle) {
				$needle = '#' . preg_quote($needle, '#') . '#ui';
			}
		} else {
			$search = '#' . preg_quote($search, '#') . '#ui';
		}
		return preg_replace(
			$search,
			strtr($replace, array('\\' => '\\\\', '$' => '\\$')),
			$string
		);
	}


	/**
	 * Finds the last position (in characters) of the search value in the string - case is ignored when doing performing a match
	 *
	 * @param  string  $haystack  The string to search in
	 * @param  string  $needle    The string to search for. This match will be done in a case-insensitive manner.
	 * @param  integer $offset    The character position to start searching from. A negative value will stop looking that many characters from the end of the string
	 * @return mixed  The integer character position of the last occurence of the needle or `FALSE` if no match
	 */
	static public function irpos($haystack, $needle, $offset=0)
	{
		// We get better performance falling back for ASCII strings
		if (!self::detect($haystack)) {
			return strripos($haystack, $needle, $offset);
		}

		if (self::$mbstring_available === NULL) {
			self::checkMbString();
		}

		if (self::$mbstring_available && function_exists('mb_strripos')) {
			return mb_strripos($haystack, $needle, $offset, 'UTF-8');
		}

		$haystack = self::lower($haystack);
		$needle   = self::lower($needle);

		return self::rpos($haystack, $needle, $offset);
	}


	/**
	 * Matches a string needle in the string haystack, returning a substring from the beginning of the needle to the end of the haystack
	 *
	 * Can optionally return the part of the haystack before the needle. Matching
	 * is done in a case-insensitive manner.
	 *
	 * @param  string  $haystack       The string to search in
	 * @param  string  $needle         The string to search for. This match will be done in a case-insensitive manner.
	 * @param  boolean $before_needle  If a substring of the haystack before the needle should be returned instead of the substring from the needle to the end of the haystack
	 * @return mixed  The specified part of the haystack, or `FALSE` if the needle was not found
	 */
	static public function istr($haystack, $needle, $before_needle=FALSE)
	{
		// We get better performance falling back for ASCII strings
		if ($before_needle == FALSE && !self::detect($haystack)) {
			return stristr($haystack, $needle);
		}

		if (self::$mbstring_available === NULL) {
			self::checkMbString();
		}

		if (self::$mbstring_available && function_exists('mb_stristr')) {
			return mb_stristr($haystack, $needle, $before_needle, 'UTF-8');
		}

		$lower_haystack = self::lower($haystack);
		$lower_needle   = self::lower($needle);

		$pos = strpos($lower_haystack, $lower_needle);

		if ($before_needle) {
			return substr($haystack, 0, $pos);
		}

		return substr($haystack, $pos);
	}


	/**
	 * Determines the length (in characters) of a string
	 *
	 * @param  string $string  The string to measure
	 * @return integer  The number of characters in the string
	 */
	static public function len($string)
	{
		if (self::$mbstring_available === NULL) {
			self::checkMbString();
		}

		if (self::$mbstring_available) {
			return mb_strlen($string, 'UTF-8');
		}

		return strlen(utf8_decode($string));
	}


	/**
	 * Converts all uppercase characters to lowercase
	 *
	 * @param  string $string  The string to convert
	 * @return string  The input string with all uppercase characters in lowercase
	 */
	static public function lower($string)
	{
		// We get better performance falling back for ASCII strings
		if (!self::detect($string)) {
			return strtolower($string);
		}

		if (self::$mbstring_available === NULL) {
			self::checkMbString();
		}

		if (self::$mbstring_available) {
			$string = mb_strtolower($string, 'utf-8');
			// For some reason mb_strtolower misses some character
			return strtr($string, self::$mb_upper_to_lower_fix);
		}

		return strtr($string, self::$upper_to_lower);
	}


	/**
	 * Trims whitespace, or any specified characters, from the beginning of a string
	 *
	 * @param  string $string    The string to trim
	 * @param  string $charlist  The characters to trim
	 * @return string  The trimmed string
	 */
	static public function ltrim($string, $charlist=NULL)
	{
		if (strlen($charlist) === 0) {
			return ltrim($string);
		}

		$search = preg_quote($charlist, '#');
		$search = str_replace('-', '\-', $search);
		$search = str_replace('\.\.', '-', $search);
		return preg_replace('#^[' . $search . ']+#Du', '', $string);
	}


	/**
	 * Compares strings using a natural order algorithm, with the resulting order having latin characters that are based on ASCII letters placed after the relative ASCII characters
	 *
	 * Please note that this function sorts based on English language sorting
	 * rules only. Locale-sepcific sorting is done by
	 * [http://php.net/strcoll strcoll()], however there are technical
	 * limitations.
	 *
	 * @param  string $str1  The first string to compare
	 * @param  string $str2  The second string to compare
	 * @return integer  `< 0` if `$str1 < $str2`, `0` if they are equal, `> 0` if `$str1 > $str2`
	 */
	static public function natcmp($str1, $str2)
	{
		$ascii_str1 = strtr($str1, self::$utf8_to_ascii);
		$ascii_str2 = strtr($str2, self::$utf8_to_ascii);

		$res = strnatcmp($ascii_str1, $ascii_str2);

		// If the ASCII representations are the same, sort by the UTF-8 representations
		if ($res === 0) {
			$res = strnatcmp($str1, $str2);
		}

		return $res;
	}


	/**
	 * Converts a UTF-8 character to a unicode code point
	 *
	 * @param  string $character  The character to decode
	 * @return string  The U+hex unicode code point for the character
	 */
	static public function ord($character)
	{
		$b       = array_map('ord', str_split($character));
		$invalid = FALSE;

		switch (strlen($character)) {
			case 1:
				if ($b[0] > 0x7F) {
					$invalid = TRUE;
					break;
				}
				$bin = decbin($b[0]);
				break;

			case 2:
				if ($b[0] < 0xC2 || $b[0] > 0xDF ||
					  $b[1] < 0x80 || $b[1] > 0xBF) {
					$invalid = TRUE;
					break;
				}
				$bin = substr(decbin($b[0]), 3) .
						   substr(decbin($b[1]), 2);
				break;

			case 3:
				if ($b[0] < 0xE0 || $b[0] > 0xEF ||
					  $b[1] < 0x80 || $b[1] > 0xBF ||
					  $b[2] < 0x80 || $b[2] > 0xBF) {
					$invalid = TRUE;
					break;
				}
				$bin = substr(decbin($b[0]), 4) .
						   substr(decbin($b[1]), 2) .
						   substr(decbin($b[2]), 2);
				break;

			case 4:
				if ($b[0] < 0xF0 || $b[0] > 0xF4 ||
					  $b[1] < 0x80 || $b[1] > 0xBF ||
					  $b[2] < 0x80 || $b[2] > 0xBF ||
					  $b[3] < 0x80 || $b[3] > 0xBF) {
					$invalid = TRUE;
					break;
				}
				$bin = substr(decbin($b[0]), 5) .
						   substr(decbin($b[1]), 2) .
						   substr(decbin($b[2]), 2) .
						   substr(decbin($b[3]), 2);
				break;

			default:
				$invalid = TRUE;
				break;
		}

		if ($invalid) {
			throw new \Exception (
				'The UTF-8 character specified is invalid'
			);
		}

		$hex = strtoupper(dechex(bindec($bin)));
		return 'U+' . str_pad($hex, 4, '0', STR_PAD_LEFT);
	}


	/**
	 * Pads a string to the number of characters specified
	 *
	 * @param  string  $string      The string to pad
	 * @param  integer $pad_length  The character length to pad the string to
	 * @param  string  $pad_string  The string to pad the source string with
	 * @param  string  $pad_type    The type of padding to do: `'left'`, `'right'`, `'both'`
	 * @return string  The input string padded to the specified character width
	 */
	static public function pad($string, $pad_length, $pad_string=' ', $pad_type='right')
	{
		$valid_pad_types = array('right', 'left', 'both');
		if (!in_array($pad_type, $valid_pad_types)) {
			throw new \Exception(
				'The pad type specified, %1$s, is not valid. Must be one of: %2$s.',
				$pad_type,
				join(', ', $valid_pad_types)
			);
		}

		// We get better performance falling back for ASCII strings
		if (!self::detect($string) && !self::detect($pad_string)) {
			static $type_map = array(
				'left'  => STR_PAD_LEFT,
				'right' => STR_PAD_RIGHT,
				'both'  => STR_PAD_BOTH
			);
			return str_pad($string, $pad_length, $pad_string, $type_map[$pad_type]);
		}


		$string_length     = self::len($string);
		$pad_string_length = self::len($pad_string);

		$pad_to_length     = $pad_length - $string_length;

		if ($pad_to_length < 1) {
			return $string;
		}

		$padded           = 0;
		$next_side        = 'left';
		$left_pad_string  = '';
		$right_pad_string = '';

		while ($padded < $pad_to_length) {

			// For pad strings over 1 characters long, they may be too long to fit
			if ($pad_to_length - $padded < $pad_string_length) {
				$pad_string = self::sub($pad_string, 0, $pad_to_length - $padded);
			}

			switch (($pad_type != 'both') ? $pad_type : $next_side) {
				case 'right':
					$right_pad_string .= $pad_string;
					$next_side = 'left';
					break;

				case 'left':
					$left_pad_string .= $pad_string;
					$next_side = 'right';
					break;
			}

			$padded += $pad_string_length;
		}

		return $left_pad_string . $string . $right_pad_string;
	}


	/**
	 * Finds the first position (in characters) of the search value in the string
	 *
	 * @param  string  $haystack  The string to search in
	 * @param  string  $needle    The string to search for
	 * @param  integer $offset    The character position to start searching from
	 * @return mixed  The integer character position of the first occurence of the needle or `FALSE` if no match
	 */
	static public function pos($haystack, $needle, $offset=0)
	{
		if (self::$mbstring_available === NULL) {
			self::checkMbString();
		}

		if (self::$mbstring_available) {
			return mb_strpos($haystack, $needle, $offset, 'UTF-8');
		}

		$offset = self::convertOffsetToBytes($haystack, $offset);

		$position = strpos($haystack, $needle, $offset);

		if ($position === FALSE) {
			return FALSE;
		}

		return strlen(utf8_decode(substr($haystack, 0, $position)));
	}


	/**
	 * Replaces matching parts of the string
	 *
	 * If `$search` and `$replace` are both arrays and `$replace` is shorter,
	 * the extra `$search` string will be replaced with an empty string. If
	 * `$search` is an array and `$replace` is a string, all `$search` values
	 * will be replaced with the string specified.
	 *
	 * @param  string $string   The string to perform the replacements on
	 * @param  mixed  $search   The string (or array of strings) to search for - see method description for details
	 * @param  mixed  $replace  The string (or array of strings) to replace with - see method description for details
	 * @return string  The input string with the specified replacements
	 */
	static public function replace($string, $search, $replace)
	{
		return str_replace($search, $replace, $string);
	}


	/**
	 * Resets the configuration of the class
	 *
	 * @internal
	 *
	 * @return void
	 */
	static public function reset()
	{
		self::$mbstring_available = NULL;
	}


	/**
	 * Reverses a string
	 *
	 * @param  string $string   The string to reverse
	 * @return string  The reversed string
	 */
	static public function rev($string)
	{
		$output = '';
		$len = strlen($string);

		static $char_lens = array(
			0xF0 => 4,
			0xE0 => 3,
			0xD0 => 2,
			0xC0 => 2
		);

		$mb_char = '';
		for ($i=0; $i<$len; $i++) {
			$char = $string[$i];
			if (ord($char) < 128) {
				$output = $char . $output;
			} else {
				switch (ord($char) & 0xF0) {
					case 0xF0:
						$output = $string[$i] . $string[$i+1] . $string[$i+2] . $string[$i+3] . $output;
						$i += 3;
						break;

					case 0xE0:
						$output = $string[$i] . $string[$i+1] . $string[$i+2] . $output;
						$i += 2;
						break;

					case 0xD0:
					case 0xC0:
						$output = $string[$i] . $string[$i+1] . $output;
						$i += 1;
						break;
				}
			}
		}

		return $output;
	}


	/**
	 * Finds the last position (in characters) of the search value in the string
	 *
	 * @param  string  $haystack  The string to search in
	 * @param  string  $needle    The string to search for.
	 * @param  integer $offset    The character position to start searching from. A negative value will stop looking that many characters from the end of the string
	 * @return mixed  The integer character position of the last occurence of the needle or `FALSE` if no match
	 */
	static public function rpos($haystack, $needle, $offset=0)
	{
		// We get better performance falling back for ASCII strings
		if (!self::detect($haystack)) {
			return strrpos($haystack, $needle, $offset);
		}

		// We don't even both trying mb_strrpos since this method is faster

		$offset = self::convertOffsetToBytes($haystack, $offset);

		$position = strrpos($haystack, $needle, $offset);

		if ($position === FALSE) {
			return FALSE;
		}

		return strlen(utf8_decode(substr($haystack, 0, $position)));
	}


	/**
	 * Trims whitespace, or any specified characters, from the end of a string
	 *
	 * @param  string $string    The string to trim
	 * @param  string $charlist  The characters to trim
	 * @return string  The trimmed string
	 */
	static public function rtrim($string, $charlist=NULL)
	{
		if (strlen($charlist) === 0) {
			return rtrim($string);
		}

		$search = preg_quote($charlist, '#');
		$search = str_replace('-', '\-', $search);
		$search = str_replace('\.\.', '-', $search);
		return preg_replace('#[' . $search . ']+$#Du', '', $string);
	}


	/**
	 * Matches a string needle in the string haystack, returning a substring from the beginning of the needle to the end of the haystack
	 *
	 * Can optionally return the part of the haystack before the needle.
	 *
	 * @param  string  $haystack       The string to search in
	 * @param  string  $needle         The string to search for
	 * @param  boolean $before_needle  If a substring of the haystack before the needle should be returned instead of the substring from the needle to the end of the haystack
	 * @return mixed  The specified part of the haystack, or `FALSE` if the needle was not found
	 */
	static public function str($haystack, $needle, $before_needle=FALSE)
	{
		if (self::$mbstring_available === NULL) {
			self::checkMbString();
		}

		if (self::$mbstring_available && function_exists('mb_strstr')) {
			return mb_strstr($haystack, $needle, $before_needle, 'UTF-8');
		}

		$pos = strpos($haystack, $needle);

		if ($pos === FALSE) {
			return $pos;
		}

		if ($before_needle) {
			return substr($haystack, 0, $pos);
		}

		return substr($haystack, $pos);
	}


	/**
	 * Extracts part of a string
	 *
	 * @param  string  $string  The string to extract from
	 * @param  integer $start   The zero-based starting index to extract from. Negative values will start the extraction that many characters from the end of the string.
	 * @param  integer $length  The length of the string to extract. If an empty value is provided, the remainder of the string will be returned.
	 * @return mixed  The extracted subtring or `FALSE` if the start is out of bounds
	 */
	static public function sub($string, $start, $length=NULL)
	{
		if (self::$mbstring_available === NULL) {
			self::checkMbString();
		}

		if (self::$mbstring_available) {
			$str_len = mb_strlen($string, 'UTF-8');
			if (abs($start) > $str_len) {
				return FALSE;
			}
			if ($length === NULL) {
				if ($start >= 0) {
					$length = $str_len-$start;
				} else {
					$length = abs($start);
				}
			}
			return mb_substr($string, $start, $length, 'UTF-8');
		}

		// We get better performance falling back for ASCII strings
		if (!self::detect($string)) {
			if ($length === NULL) {
				if ($start >= 0) {
					$length = strlen($string)-$start;
				} else {
					$length = abs($start);
				}
			}
			return substr($string, $start, $length);
		}


		// This is the slowest version
		$str_len = strlen(utf8_decode($string));

		if (abs($start) > $str_len) {
			return FALSE;
		}

		// Optimize looking by changing to negative start positions if the
		// start is in the second half of the string
		if ($start > $str_len/2) {
			$start = 0-($str_len-$start);
		}

		// Substrings to the end of the string are pretty simple
		$start  = self::convertOffsetToBytes($string, $start);
		$string = substr($string, $start);

		if ($length === NULL) {
			return $string;
		}

		$length = self::convertOffsetToBytes($string, $length);
		return substr($string, 0, $length);
	}


	/**
	 * Trims whitespace, or any specified characters, from the beginning and end of a string
	 *
	 * @param  string $string    The string to trim
	 * @param  string $charlist  The characters to trim, .. indicates a range
	 * @return string  The trimmed string
	 */
	static public function trim($string, $charlist=NULL)
	{
		if (strlen($charlist) === 0) {
			return trim($string);
		}

		$search = preg_quote($charlist, '#');
		$search = str_replace('-', '\-', $search);
		$search = str_replace('\.\.', '-', $search);
		return preg_replace('#^[' . $search . ']+|[' . $search . ']+$#Du', '', $string);
	}


	/**
	 * Converts the first character of the string to uppercase.
	 *
	 * @param  string $string  The string to process
	 * @return string  The processed string
	 */
	static public function ucfirst($string)
	{
		return self::upper(self::sub($string, 0, 1)) . self::sub($string, 1);
	}


	/**
	 * Converts the first character of every word to uppercase
	 *
	 * Words are considered to start at the beginning of the string, or after any
	 * whitespace character.
	 *
	 * @param  string $string  The string to process
	 * @return string  The processed string
	 */
	static public function ucwords($string)
	{
		return preg_replace_callback(
			'#(?<=^|\s|[\x{2000}-\x{200A}]|/|-|\(|\[|\{|\||"|^\'|\s\'|â€˜|â€œ)(.)#u',
			array('self', 'ucwordsCallback'),
			$string
		);
	}


	/**
	 * Handles converting a character to uppercase for ::ucwords()
	 *
	 * @param array $match  The regex match from ::ucwords()
	 * @return string  The uppercase character
	 */
	static private function ucwordsCallback($match)
	{
		return self::upper($match[1]);
	}


	/**
	 * Converts all lowercase characters to uppercase
	 *
	 * @param  string $string  The string to convert
	 * @return string  The input string with all lowercase characters in uppercase
	 */
	static public function upper($string)
	{
		// We get better performance falling back for ASCII strings
		if (!self::detect($string)) {
			return strtoupper($string);
		}

		if (self::$mbstring_available === NULL) {
			self::checkMbString();
		}

		if (self::$mbstring_available) {
			$string = mb_strtoupper($string, 'utf-8');
			// For some reason mb_strtoupper misses some character
			return strtr($string, self::$mb_lower_to_upper_fix);
		}

		return strtr($string, self::$lower_to_upper);
	}


	/**
	 * Wraps a string to a specific character width
	 *
	 * @param  string  $string  The string to wrap
	 * @param  integer $width	The character width to wrap to
	 * @param  string  $break   The string to insert as a break
	 * @param  boolean $cut     If words longer than the character width should be split to fit
	 * @return string  The input string with all lowercase characters in uppercase
	 */
	static public function wordwrap($string, $width=75, $break="\n", $cut=FALSE)
	{
		// We get better performance falling back for ASCII strings
		if (!self::detect($string)) {
			return wordwrap($string, $width, $break, $cut);
		}

		$words = preg_split('#(?<=\s|[\x{2000}-\x{200A}])#ue', $string);

		$output = '';

		$line_len = 0;
		foreach ($words as $word) {
			$word_len = self::len($word);

			// Shorten up words that are too long
			while ($cut && $word_len > $width) {
				$output  .= $break;
				$output  .= self::sub($word, 0, $width);
				$line_len = $width;
				$word	  = self::sub($word, $width);
				$word_len = self::len($word);
			}

			if ($line_len && $line_len + $word_len > $width) {
				$output  .= $break;
				$line_len = 0;
			}
			$output   .= $word;
			$line_len += $word_len;
		}

		return $output;
	}
}